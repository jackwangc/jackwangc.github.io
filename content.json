{"meta":{"title":"叶落 知秋","subtitle":null,"description":"个人知识总结","author":"Jack Wang","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-08-04T01:56:50.000Z","updated":"2019-08-04T03:18:23.779Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-04T01:56:22.000Z","updated":"2019-08-04T03:18:50.115Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"实验室 .net 项目常识总结","slug":"20190804","date":"2019-08-04T03:15:26.000Z","updated":"2019-08-04T08:28:38.365Z","comments":true,"path":"2019/08/04/20190804/","link":"","permalink":"http://yoursite.com/2019/08/04/20190804/","excerpt":"","text":"实验室 .net 项目常识总结sql server 常用操作基础操作select 语法 select Column-name from table-name 查询基本语法 SELECT DISTINCT column_name,column_name FROM table_name 查询列出不同（distinct）的值 SELECT column_name,column_name FROM table_name WHERE column_name operator value 条件查询 比较运算: 条件：列，比较运算符，值 比较运算符包涵：= &gt; &lt; &gt;= ,&lt;=, !=,&lt;&gt; 表示（不等于） 逻辑运算: And:与 同时满足两个条件的值; Or:或 满足其中一个条件的值; Not:非 满足不包含该条件的值 特殊条件: 空值判断： is null ; between and (在之间的值) ; in(5000,3000,1500) ; like 模糊查询 Select * from emp where ename like &#39;M%&#39; SELECT column_name,column_name FROM table_name ORDER BY column_name,column_name ASC|DESC 对查询记录排序 SELECT column_name(s) FROM table_name LIMIT number mysql 语法; SELECT TOP number|percent column_name(s)FROM table_name; sql server 语法 返回规定数目 insert 语法 语法一：INSERT INTO table_name VALUES (value1,value2,value3,...) 语法二：INSERT INTO table_name (column1,column2,column3,...) VALUES (value1,value2,value3,...) update 语法 UPDATE table_name SET column1=value1,column2=value2,... WHERE some_column=some_value 更新语法 delete 语法 DELETE FROM table_name WHERE some_column=some_value DELETE * FROM table_name; 删除表中数据 DELETE FROM TABLE_NAME WHERE &lt;搜索条件&gt; 删除前多少行数据 搜索条件可以是判断和语句,select top 2000 id from tablename order by drop 语法 DROP TABLE table_name 删除表 DROP DATABASE database_name 删除数据库 DROP INDEX index_name ON table_name 删除索引 高级操作高级删除12345678910111213141516171819202122231. 删除重复记录-- 查找重复记录根据 单个字段 storecode 判断select * from K_D_StoreReceiptwhere StoreCode in (select StoreCode from K_D_StoreReceipt group by StoreCode having count(StoreCode) &gt; 1) -- 删除多余重复记录delete from people where peopleName in (select peopleName from people group by peopleName having count(peopleName) &gt; 1) and peopleId not in (select min(peopleId) from people group by peopleName having count(peopleName)&gt;1) // row_number函数在数据库中的功能是为每一行 按照一定的规则生成一个编号// partition by 用于给结果集分组/*删除 keyId重复数据 中的另外几条*/delete [A2] from (select row_number() over (Partition By keyId order by keyId) as keyId2,* from A ) as [A2]where [A2].keyId2 &gt;1 /*删除 所有列都重复数据 中的另外几条*/delete [A2] from (select row_number() over (Partition By keyId,info order by keyId) as keyId2,* from A ) as [A2]where [A2].keyId2 &gt;1 多表查询1234SELECT Websites.id, Websites.name, access_log.count, access_log.dateFROM WebsitesINNER JOIN access_log # inener join, left, right, fullON Websites.id=access_log.site_id; 合并查询123SELECT column_name(s) FROM table1 # 展示合并后的查询结果UNION # UNION ALL 允许重复SELECT column_name(s) FROM table2; INSERT INTO SELECT INSERT INTO table2 SELECT * FROM table1; 把数据插入另外一张表 alter 向表中添加约束sql server 常用数据类型 数据类型 描述 数据类型 描述 int 整型 float 浮点型 date 日期 time 时间 char 固定字符串 varchar 可变字符串 建表12345678910111213141516171819202122232425262728293031# 建立数据库CREATE DATABASE my_db;# 建表CREATE TABLE table_name(column_name1 data_type(size), # PersonID int,column_name2 data_type(size), # LastName varchar(255),column_name3 data_type(size) IDENTITY(1,1), # 执行 auto-increment 任务, 自增....);# 约束实例CREATE TABLE Persons(P_Id int NOT NULL PRIMARY KEY, # 主键 对主键命名 主键唯一LastName varchar(255) NOT NULL CHECK (P_Id&gt;0), # CHECK 限制列中值得范围FirstName varchar(255) DEFAULT 'Sandnes', # default 向列中插入默认值Address varchar(255) FOREIGN KEY REFERENCES Persons(P_Id), # 外键City varchar(255)// CONSTRAINT pk_PersonID PRIMARY KEY (P_Id,LastName) 多个列联合起来形成一个主键// CONSTRAINT fk_PerOrders FOREIGN KEY (P_Id) REFERENCES Persons(P_Id) 对外键进行命名# 表已创建对键的操作ALTER TABLE Orders # ALTER TABLE 语句用于在已有的表中添加、删除或修改列ADD CONSTRAINT pk_PersonID PRIMARY KEY (P_Id,LastName # 创建主键ADD FOREIGN KEY (P_Id) REFERENCES Persons(P_Id) # 创建外键 一个表中的 FOREIGN KEY 需指向另一个表中的 PRIMARY KEYADD CONSTRAINT chk_Person CHECK (P_Id&gt;0 AND City='Sandnes') # check 约束DROP CONSTRAINT fk_PerOrders # 删除外键ALTER COLUMN column_name datatype # 修改列的类型(modify-mysql) sql 约束（Constraints） 约束 功能 not null 约束强制列不接受 NULL 值 UNIQUE 约束唯一标识数据库表中的每条记录(不唯一) PRIMARY KEY 约束唯一标识数据库表中的每条记录(唯一) FOREIGN KEY 用于预防破坏表之间连接的行为,也能防止非法数据插入外键列 CHECK 限制列中值得范围 DEFAULT 向列中插入默认值 INDEX 索引, 用来加速搜索和查询 sql 视图 视图是可视化的表。在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表 什么情况下会用到视图 一个比较复杂的查询不想每次都写很多语句，就可以写个视图 给特定用户开放某些表的读取权限，但要加一些行和列的限制 视图的优点 使用视图，可以定制用户数据，聚焦特定的数据 使用视图，可以简化数据操作 使用视图，基表中的数据就有了一定的安全性 可以合并分离的数据，创建分区视图 dev 操作常见问题 无法修改gridview 数据时，将表属性中更新检查更改为 never 控件由于都是服务器控件点击时会刷新页面 可以用autopostback=false 屏蔽掉刷新 aspxSplitter 分隔符用法 无嵌套 splitter 123456789101112&lt;dx:ASPxSplitter ID=\"ASPxSplitter1\" runat=\"server\" Height=\"100%\" Width=\"100%\" ClientIDMode=\"AutoID\" &gt; &lt;Panes&gt; &lt;dx:SplitterPane Size=\"30%\" ScrollBars =\"Auto\"&gt; &lt;ContentCollection&gt; // 标签1 添加进去之后 必须增加这两个标签 &lt;dx:SplitterContentControl&gt; // 标签2 &lt;/dx:SplitterContentControl&gt; &lt;/ContentCollection&gt; &lt;/dx:SplitterPane&gt; &lt;dx:SplitterPane&gt;&lt;/dx:SplitterPane&gt; &lt;/Panes&gt;&lt;/dx:ASPxSplitter&gt; 嵌套 splitter 12345678910111213141516171819202122232425&lt;dx:ASPxSplitter ID=\"ASPxSplitter1\" runat=\"server\" Height=\"100%\" Width=\"100%\" ClientIDMode=\"AutoID\" &gt; &lt;Panes&gt; &lt;dx:SplitterPane Size=\"30%\" ScrollBars =\"Auto\"&gt; &lt;ContentCollection&gt; // 标签1 添加进去之后 必须增加这两个标签 &lt;dx:SplitterContentControl&gt; // 标签2 &lt;/dx:SplitterContentControl&gt; &lt;/ContentCollection&gt; &lt;/dx:SplitterPane&gt; &lt;dx:SplitterPane&gt; &lt;Panes&gt; &lt;dx:SplitterPane Size=30%&gt; &lt;ContentCollection&gt; &lt;/ContentCollection&gt; &lt;/dx:SplitterPane&gt; &lt;dx:SplitterPane&gt; &lt;ContentCollection&gt; &lt;/ContentCollection&gt; &lt;/dx:SplitterPane&gt;&lt;d &lt;/Panes&gt; &lt;/dx:SplitterPane&gt; &lt;/Panes&gt;&lt;/dx:ASPxSplitter&gt; treeView 用法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;dx:ASPxTreeView ID=\"ASPxTreeView1\" runat=\"server\" ClientIDMode=\"AutoID\"EnableCallBacks=\"True\" AllowSelectNode=\"True\" OnVirtualModeCreateChildren=\"treeView_VirtualModeCreateChildren\"&gt; // 初始化treeView 列表&lt;/dx:ASPxTreeView&gt;//////第一种方法// 适合用于表中有明确父子关系的// treeView 后台添加数据方法public void newCreateTree(TreeViewVirtualModeCreateChildrenEventArgs e)&#123; // 结果 List&lt;TreeViewVirtualNode&gt; children = new List&lt;TreeViewVirtualNode&gt;(); f(string.IsNullOrEmpty(e.NodeName))&#123; // 1. 建立头节点 // 存放节点方法 TreeViewVirtualNode(string name, string text); TreeViewVirtualNode childNode = new TreeViewVirtualNode(root_department.id.ToString(), root_department.DepartmentName, root_department.S_Department_Type.ImageUrl); childNode.IsLeaf = false; children.Add(childNode); &#125;else&#123; // 头节点已经建立 然后建立子节点 view_department_child() &#125; e.Children = children;&#125; // 建立子节点 // 参数 1.结果集 // 2. 查询参数private void view_department_child(List&lt;TreeViewVirtualNode&gt; children, int root_department_id)&#123; // 建立节点 TreeViewVirtualNode childNode = new TreeViewVirtualNode(department.id.ToString(), department.DepartmentName); // 当节点为叶子节点时 childNode.IsLeaf = true; childNode.Enabled = false; children.Add(childNode);&#125;///// 第二种方法// 页面加载时添加节点// 表中没有明确的父子关系//例子 设备树的建立protected void Page_Load(object sender, EventArgs e) &#123; if (!Page.IsPostBack) &#123; ASPxTreeView1.Dispose(); //清理树 TreeViewNodeCollection tnc = this.ASPxTreeView1.Nodes; // 查询到大类 var bigCategorys = from t in db.F_FacilityBigCategory select t; foreach (var bigCategory in bigCategorys) &#123; var smallCategorys = from t in db.F_FacilitySmallCategory where t.BigCategoryID == bigCategory.ID select t; if (smallCategorys != null) &#123; TreeViewNode children = new TreeViewNode(bigCategory.Name, bigCategory.ID.ToString()); // 查询到小类 foreach (var smallCategory in smallCategorys) &#123; TreeViewNode son = new TreeViewNode(smallCategory.Name, smallCategory.ID.ToString()); // 查询到设备 var facilitys = from t in db.F_FacilityInfo where t.BigCategoryID == smallCategory.BigCategoryID &amp;&amp; t.SmallCategoryID == smallCategory.ID select t; if (facilitys != null) &#123; foreach(var facility in facilitys)&#123; TreeViewNode sun = new TreeViewNode(facility.Name,facility.ID.ToString()); // 设备添加 son.Nodes.Add(sun); &#125; &#125; // 小类添加 children.Nodes.Add(son); &#125; // 大类添加 tnc.Add(children); &#125; &#125; &#125; &#125; 从一个控件传值到另外一个控件12345678910111213141516&lt;ClientSideEvents NodeClick=\"function(s, e) &#123; click_callback.PerformCallback(e.node.name);&#125;\"/&gt;&lt;dx:ASPxCallbackPanel ID=\"click_callback\" runat=\"server\" LoadingPanelText=\"请稍后\" OnCallback=\"click_node\" Width=\"100%\" ClientInstanceName=\"click_callback\"&gt; &lt;PanelCollection&gt; &lt;dx:PanelContent ID=\"PanelContent1\" runat=\"server\" SupportsDisabledAttribute=\"True\"&gt; &lt;/dx:PanelContent&gt; &lt;/PanelCollection&gt; &lt;/dx:ASPxCallbackPanel&gt;// 后台调用 protected void click_node(object sender, CallbackEventArgsBase e)&#123; e.Parameter &#125; 自定义数据源123456789// 1. 添加数据源&lt;asp:LinqDataSource ID=\"LinqDataSource1\" runat=\"server\"&gt;&lt;/asp:LinqDataSource&gt;// 2. 添加隐藏域 &lt;asp:HiddenField ID=\"hide_type_id\" runat=\"server\" /&gt;// 3. 后台给隐藏域赋值hide_type_id.Value = e.Parameter;// 4. 数据源自定义（将隐藏域条件发送到数据源）// 在数据源配置页面里选择// 5. 必加属性 EnableViewState=\"false\" 不加不能删除 弹出框123456789101112131415161718192021222324252627282930313233// 1. 调用弹出框&lt;ClientSideEvents ItemClick=\"function(s, e) &#123; MenuItemClick(e); &#125;\"&gt;&lt;/ClientSideEvents&gt;// 2. js function MenuItemClick(e) &#123; switch (e.item.name) &#123; case \"addType\": NewType.Show(); break; &#125; &#125;// 3. 弹出框页面 &lt;dx:ASPxPopupControl ID=\"addType\" runat=\"server\" CloseAction=\"CloseButton\" Width=\"300\" PopupHorizontalAlign=\"WindowCenter\"PopupVerticalAlign=\"WindowCenter\" ClientInstanceName=\"NewDepartment\" HeaderText=\"新建类型\" AllowDragging=\"True\" EnableAnimation=\"False\" EnableViewState=\"False\"&gt; &lt;%--作用: 清空--%&gt; &lt;ClientSideEvents PopUp=\"function(s, e) &#123; ASPxClientEdit.ClearGroup('NewDeptGroup'); NewDepartmentName.Focus(); &#125;\" /&gt; &lt;ContentCollection&gt; &lt;dx:PopupControlContentControl runat=\"server\" SupportsDisabledAttribute=\"True\"&gt; &lt;dx:ASPxPanel ID=\"aspPanel\" runat=\"server\" ClientIDMode=\"AutoID\" Width=\"207px\"&gt; &lt;PanelCollection&gt; &lt;dx:PanelContent runat=\"server\" SupportsDisabledAttribute=\"True\"&gt; &lt;table cellpadding=\"0\" cellspacing=\"0\" style=\"width: 132%\"&gt; &lt;tr&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/dx:PanelContent&gt; &lt;/PanelCollection&gt; &lt;/dx:ASPxPanel&gt; &lt;/dx:PopupControlContentControl&gt; &lt;/ContentCollection&gt; &lt;/dx:ASPxPopupControl&gt; GirdView 初级用法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 1. 前台建立 gridview// 2. gridview 中文化&lt;SettingsText EmptyDataRow=\"无数据显示\" /&gt;&lt;SettingsPager&gt;&lt;Settings ShowFilterRow=\"True\" /&gt;&lt;Summary Text=\"第&#123;0&#125;页 共&#123;1&#125;页 (共&#123;2&#125; 项)\" /&gt;&lt;/SettingsPager&gt;&lt;SettingsLoadingPanel Text=\"请稍后\" /&gt;&lt;Settings ShowFilterRow=\"True\" /&gt;&lt;dx:GridViewCommandColumn ShowInCustomizationForm=\"True\" VisibleIndex=\"0\" Caption=\"操作\"&gt; &lt;EditButton Visible=\"True\" Text=\"编辑\"&gt;&lt;/EditButton&gt; &lt;DeleteButton Visible=\"True\" Text=\"删除\"&gt;&lt;/DeleteButton&gt; &lt;ClearFilterButton Visible=\"True\" Text=\"清除过滤条件\"&gt; &lt;Image Url=\"~/Images/gclear.png\"&gt;&lt;/Image&gt; &lt;/ClearFilterButton&gt; &lt;CancelButton Text=\"取消\"&gt; &lt;Image Url=\"~/Images/gcancel.png\"&gt; &lt;/Image&gt; &lt;/CancelButton&gt; &lt;UpdateButton Text=\"确认\"&gt; &lt;/UpdateButton&gt;&lt;/dx:GridViewCommandColumn&gt;// 3. gridview 后台事件OnRowUpdating=\"row_editing\" // 更新事件OnStartRowEditing=\"start_row_editing\" // 点击事件OnDetailRowExpandedChanged=\"expand_detail\" // 细节展开ClientIDMode=\"AutoID\" EnableRowsCache=\"true\" KeyFieldName=\"ID\" // 自定义编辑框&lt;SettingsDetail ShowDetailRow=\"true\" ExportMode=\"All\" ShowDetailButtons=\"true\" AllowOnlyOneMasterRowExpanded=\"true\" /&gt; // 展示细节&lt;Templates&gt; &lt;EditForm&gt; &lt;div style=\"padding:4px 4px 3px 4px\"&gt; &lt;dx:ASPxPageControl ID=\"ASPxPageControl1\" runat=\"server\" Width=\"100%\" ActiveTabIndex=\"0\"&gt; &lt;TabPages&gt; &lt;dx:TabPage Text=\"基本信息\" Visible=\"true\"&gt; &lt;ContentCollection&gt; &lt;dx:ContentControl&gt; &lt;dx:ASPxGridViewTemplateReplacement ID =\"Editors\" ReplacementType=\"EditFormEditors\" runat=\"server\"/&gt; &lt;/dx:ContentControl&gt; &lt;/ContentCollection&gt; &lt;/dx:TabPage&gt; &lt;/TabPages&gt; &lt;/dx:ASPxPageControl&gt; &lt;/div&gt; &lt;div style=\"text-align: right; padding: 2px 2px 2px 2px\"&gt; &lt;dx:ASPxGridViewTemplateReplacement ID=\"UpdateButton\" ReplacementType=\"EditFormUpdateButton\" runat=\"server\"&gt;&lt;/dx:ASPxGridViewTemplateReplacement&gt; &lt;dx:ASPxGridViewTemplateReplacement ID=\"CancelButton\" ReplacementType=\"EditFormCancelButton\"runat=\"server\"&gt;&lt;/dx:ASPxGridViewTemplateReplacement&gt; &lt;/div&gt; &lt;/EditForm&gt;&lt;/Templates&gt;// 建立gridview下拉框列&lt;dx:GridViewDataComboBoxColumn FieldName=\"ProductCode\" Caption=\"产品编码\" ReadOnly=\"true\" VisibleIndex=\"4\" &gt; &lt;PropertiesComboBox ValueType=\"System.String\" DataSourceID=\"LinqDataSourceCoding\" TextField=\"ProductName\" ValueField=\"Coding\"&gt; &lt;/PropertiesComboBox&gt;&lt;/dx:GridViewDataComboBoxColumn&gt; 下拉框1234567891011121314151617181920212223242526272829303132333435363738// 1. combo box 优选//combo box 是一个 文本输入框 和 一个 列表或下拉列表 的 组合。//用户可以在文本输入框中输入内容（这时combo box可以有以下行为：combo box的列表可以在它的所有选项中寻找匹配项，并高亮显示一个可能的匹配项// 1.1 前台绑定数据方法// TextField 文本显示 valueId 实际选值 输入匹配规则 IncrementalFilteringMode=\"Contains\"&lt;dx:ASPxComboBox ID=\"ASPxComboBox1\" runat=\"server\" DataSourceID=\"LinqDataSourcePackage\" TextField=\"Name\" ValueField=\"ID\" IncrementalFilteringMode=\"Contains\"&gt;&lt;/dx:ASPxComboBox&gt;// 1.2 后台绑定数据方法// 1.2.1 后台更加灵活var levelList = kkdb.GetTable&lt;K_P_Level&gt;();foreach(var i in levelList)&#123; ASPxComboBox4.Items.Add(i.Name+\"|\"+i.Coding,i.ID);&#125;ASPxComboBox4.SelectedIndex = -1;ASPxComboBox4.DataBind();// 1.2.1 comboBox1.DataSource = levelList;comboBox1.DisplayMember = \"Name\";comboBox1.ValueMember = \"Value\"; var aa = ASPxComboBox4.Value;// 2. dropdownList//用户点击drop down list时，会展开一个一个“下拉”的列表，用户可以从列表中选择一项。//这些选项都是预先定义好的，用户只能从中选择，不能自己输入新的内容。// 2. combo box 点击事件// 无法触发 onselect 事件是因为缺少属性 autopostback// 前台必加属性OnSelectedIndexChanged=\"SetCodeText\" EnableViewState=\"true\" AutoPostBack=\"true\"// c# 方法protected void SetCodeText(object source, EventArgs e)&#123;&#125;// 使用后台方法会触发刷新 可以使用前台js 方法 &lt;dx:ASPxComboBox ID=\"ASPxComboBoxForProduct\" runat=\"server\" IncrementalFilteringMode=\"Contains\"&gt; &lt;ClientSideEvents SelectedIndexChanged=\"function(s,e)&#123;alert(1)&#125;\"/&gt;&lt;/dx:ASPxComboBox&gt; 前台调用后台方法123456789101112131415161718192021222324// 1. ajax // 1.1 建立ashx文件//$.ajax(&#123; type: \"POST\", data: &#123; \"surfaceID\": surfaceID &#125;, url: \"../handler/GetSurfaceModelHandler.ashx\", success: getsurfacemodelsucc &#125;);// 2. function Init() &#123; var v = \"来电\"; var s = '&lt;%=receiveCall(\"'+v+'\") %&gt;'; alert(s); &#125; public string receiveCall(string strNum)&#123; strNum = \"小明\" + strNum; return strNum;&#125;// 3. 后台调用前台123456789101112 //如果有UpdatePanel就用如下代码调用前台js ScriptManager.RegisterStartupScript(UpdatePanel1, this.Page.GetType(), \"\", \"Ceshi();\", true); //如果没有就如下代码 this.Page.ClientScript.RegisterStartupScript(this.Page.GetType(), \"\", \"&lt;script&gt;Ceshi();&lt;/script&gt;\", true);1. 后台 // 使用前台的代码 private void useJs(String jsCode) &#123; ScriptManager.RegisterClientScriptBlock(this, this.GetType(), this.UniqueID, jsCode, true); &#125;2. 前台 &lt;asp:ScriptManager runat=\"server\"&gt;&lt;/asp:ScriptManager&gt; updatePanel 异步刷新模块 linq 相关操作12 ASPXButton123456// 1. 后台方法 拖动添加 onclik// 2. 前台方法 调用 js&lt;dx:ASPxButton Text=\"添加包装物料\" ID=\"newFormulaButton\" runat=\"server\" &gt; &lt;ClientSideEvents Click=\"function(s, e) &#123; MenuItemClick(e);&#125;\"/&gt;&lt;/dx:ASPxButton&gt; 添加产品类型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 添加类型下拉全国// 1. 引入cs 文件using DigitalSystem.utl;// 2. 前台建立类型下拉框组件&lt;dx:ASPxDropDownEdit ID=\"ddSelectDepartment\" runat=\"server\" Width=\"100%\" ClientInstanceName=\"ddSelectDepartment\" EnableAnimation=\"False\" ReadOnly=\"True\"&gt; &lt;DropDownWindowTemplate&gt; &lt;div style=\"overflow: auto; height: 300px;\"&gt; &lt;dx:ASPxTreeView ID=\"ASPxTreeView1\" runat=\"server\" OnVirtualModeCreateChildren=\"ASPxTreeView1_VirtualModeCreateChildren\" ClientIDMode=\"AutoID\" EnableAnimation=\"False\" EnableCallBacks=\"true\" AllowSelectNode=\"True\" &gt; &lt;ClientSideEvents NodeClick=\"function(s,e)&#123;click_callbackForProduct.PerformCallback(e.node.name); ddSelectDepartment.HideDropDown();ddSelectDepartment.SetKeyValue(e.node.name); ddSelectDepartment.SetText(e.node.GetText());&#125;\" /&gt; &lt;/dx:ASPxTreeView&gt; &lt;/div&gt; &lt;/DropDownWindowTemplate&gt;&lt;/dx:ASPxDropDownEdit&gt;// 3. 前台建立产品下拉框组件&lt;dx:ASPxCallbackPanel ID=\"click_callbackForProduct\" LoadingPanelText=\"请稍后\" ClientInstanceName=\"click_callbackForProduct\" runat=\"server\" Width=\"100%\" OnCallback=\"click_nodeforProduct\"&gt; &lt;PanelCollection&gt; &lt;dx:PanelContent&gt; &lt;dx:ASPxComboBox ID=\"ASPxComboBoxForProduct\" runat=\"server\" IncrementalFilteringMode=\"Contains\"&gt;&lt;/dx:ASPxComboBox&gt; &lt;/dx:PanelContent&gt; &lt;/PanelCollection&gt;&lt;/dx:ASPxCallbackPanel&gt;// 4. 后台配置数据源// 4.1 配置 treeviewprotected void ASPxTreeView1_VirtualModeCreateChildren(object source, DevExpress.Web.ASPxTreeView.TreeViewVirtualModeCreateChildrenEventArgs e) &#123; utl.newCreateTree(e, 1); &#125;// 4.2 接收传过来的值click_callbackForProductprotected void click_nodeforProduct(object sender, CallbackEventArgsBase e) &#123; int typeId = int.Parse(e.Parameter); ArrayList result = new ArrayList(); result.Add(typeId); // 查询类型下的所有子类型 utl.findTypelList(typeId, result); List&lt;K_P_Product&gt; productList = new List&lt;K_P_Product&gt;(); productList = utl.findAllProduct(result); ASPxComboBoxForProduct.DataSource = productList; ASPxComboBoxForProduct.TextField = \"ProductName\"; ASPxComboBoxForProduct.ValueField = \"ID\"; ASPxComboBoxForProduct.DataBind(); &#125; 添加仓库产品1234567891011121314151617181920212223242526272829// 前台同上// 后台protected void ASPxTreeView1_VirtualModeCreateChildren(object source, DevExpress.Web.ASPxTreeView.TreeViewVirtualModeCreateChildrenEventArgs e) &#123; db.newDepotTree(e, 1); &#125; protected void click_nodeforProduct(object sender, CallbackEventArgsBase e) &#123; int depotId = int.Parse(e.Parameter); // 找到仓库中不重复的产品名称 var productList = pd.findAllProductInDepot(depotId); // 产品名称去重 var nameList = productList.GroupBy(p =&gt; new &#123; p.ProductCode &#125;).Select(g =&gt; g.First()); //var nameList = from p in productList select p.ProductCode.Distinct(); ArrayList arr = new ArrayList(); foreach (var i in nameList) &#123; arr.Add(i.ProductCode); &#125; // 找到对应的产品 var reList = pd.findAllProductByName(arr); ASPxComboBoxForProduct.DataSource = reList; ASPxComboBoxForProduct.TextField = \"ProductName\"; ASPxComboBoxForProduct.ValueField = \"ID\"; ASPxComboBoxForProduct.DataBind(); &#125; 获取url 中的参数123456789101112&lt;iframe src=\"floder/productFormula.aspx?productInfoId=1\"&gt;\"&lt;a href=\" + \"/projectinfo/ProjectSearchDetailInfo.aspx?projectInfoId=\" + projectID + \"&gt;\"pagelod:if(!IsPostBack) &#123; if (Request[\"productInfoId\"]!=null) &#123; HideFieldForProductID.Value = Request[\"productInfoId\"]; prductID = int.Parse(Request[\"productInfoId\"]); ASPxGridViewForProduct.DataBind(); &#125; &#125; 设置 session1234// 设值Session[\"product_formula\"] = e.EditingKeyValue.ToString();// 取值HideFieldForProductID.Value = Convert.ToString(Session[\"product_formula\"]); 编号生成123456789if (!IsPostBack) &#123; // 生成一个入库单编号 string code = pd.generateNumber(\"K_D_StoreReceipt\", \"入库\"); // 隐藏域赋值 storeReceipt.Value = code; // 编号赋值 StoreCode.Text = code; &#125; 文字圈框123456&lt;fieldset&gt; &lt;legend&gt; &lt;dx:ASPxLabel ID=\"ASPxLabel7\" runat=\"server\" Text=\"修改/保存工艺参数\" Font-Size=\"Large\"&gt; &lt;/dx:ASPxLabel&gt; &lt;/legend&gt;&lt;/fieldset&gt; 数据类型转换12345678910111213Convert.toInt32();Conver.toString();float.prase();时间类型 // 只包含年月日date// 转换DateTime now = Convert.ToDateTime(date);now.date = date;// 包含具体时间datetimeDateTime now = Convert.ToDateTime(date); excel 导出123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104// 1. 设置选取要打印的内容&lt;!--startprint1--&gt;&lt;!--endprint1--&gt;// 2. 获取html元素&lt;dx:ASPxButton ID=\"exportExcel\" runat=\"server\" Text=\"导出表格\" AutoPostBack=\"false\"&gt; &lt;ClientSideEvents Click=\"function(s,e)&#123;begin();&#125;\" /&gt;&lt;/dx:ASPxButton&gt;&lt;dx:ASPxButton ID=\"buttonToSaveHtml\" ClientInstanceName=\"buttonToSaveHtml\" ClientVisible=\"false\" runat=\"server\" AutoPostBack=\"false\"&gt; &lt;ClientSideEvents Click=\"function(s,e)&#123;preview(1);&#125;\" /&gt;&lt;/dx:ASPxButton&gt;&lt;dx:ASPxButton ID=\"createExcel\" ClientInstanceName=\"createExcel\" runat=\"server\" ClientVisible=\"false\" AutoPostBack=\"false\" OnClick=\"createExcel_Click\"&gt;&lt;/dx:ASPxButton&gt;&lt;dx:ASPxCallbackPanel ID=\"toexcel\" ClientInstanceName=\"toexcel\" runat=\"server\" OnCallback=\"toexcel_Callback\"&gt; &lt;ClientSideEvents EndCallback=\"download\" /&gt; &lt;PanelCollection&gt; &lt;dx:PanelContent&gt; &lt;dx:ASPxHiddenField ID=\"tablehtml\" runat=\"server\" ClientInstanceName=\"tablehtml\"&gt;&lt;/dx:ASPxHiddenField&gt; &lt;/dx:PanelContent&gt; &lt;/PanelCollection&gt;&lt;/dx:ASPxCallbackPanel&gt; function begin() &#123; var savehtmlbutton = document.getElementById(\"&lt;%=buttonToSaveHtml.ClientID%&gt;\"); savehtmlbutton.click();&#125;function download() &#123; var createexcelbutton = document.getElementById(\"&lt;%=createExcel.ClientID%&gt;\"); //setTimeout(function () &#123; createexcelbutton.click(); &#125;, 5000); createexcelbutton.click();&#125; function preview(oper) &#123; if (oper &lt; 10) &#123; bdhtml = window.document.body.innerHTML;//获取当前页的html代码 //winname = window.open('', \"_blank\", ''); sprnstr = \"&lt;!--startprint\" + oper + \"--&gt;\";//设置打印开始区域 eprnstr = \"&lt;!--endprint\" + oper + \"--&gt;\";//设置打印结束区域 prnhtml = bdhtml.substring(bdhtml.indexOf(sprnstr) + 18); //从开始代码向后取html prnhtml = prnhtml.substring(0, prnhtml.indexOf(eprnstr));//从结束代码向前取html // window.document.body.innerHTML = prnhtml; var temp1 = prnhtml.split('&lt;div&gt;'); //alert(\"temp1=\" + temp1); var temp2 = temp1[1]; //alert(\"temp2=\" + temp2); var temp3 = temp2.split('&lt;/div&gt;'); //alert(\"temp3=\" + temp3); var tablehtml = temp3[0]; //alert(\"prnhtml=\" + prnhtml); //alert(\"tablehtml=\" + tablehtml); toexcel.PerformCallback(tablehtml); //alert(1); &#125;&#125;// 3. 后台方法protected void toexcel_Callback(object sender, DevExpress.Web.ASPxClasses.CallbackEventArgsBase e) &#123; if (e.Parameter.ToString() == \"empty\") &#123; tablehtml[\"htmltable\"] = \"\"; &#125; else &#123; int cols = submitGrid.Columns.Count; //int tableid = Convert.ToInt32(TableName); //var table = db.D_TableInfo.SingleOrDefault(t =&gt; t.ID == tableid); string temp1 = e.Parameter.ToString(); string temp2 = temp1.Substring(4, temp1.Length - 7); string[] sArray = Regex.Split(temp2, \"&lt;tbody&gt;\", RegexOptions.IgnoreCase); string tableline = \"&lt;tbody&gt;&lt;tr class=\\\"lup\\\" align=\\\"center\\\"&gt;\\n\\t\\t\\t\\t\\t&lt;th colspan=\\\"\" + cols + \"\\\" rowspan=\\\"1\\\" bordercolor=\\\"#333333\\\" style=\\\"font-size:large;border-width:1px;border-style:solid;\\\"&gt;\" + TableName + \"&lt;/th&gt;&lt;/tr&gt;\" + \"&lt;tr class=\\\"lup\\\" align=\\\"center\\\"&gt;\\n\\t\\t\\t\\t\\t&lt;th align=\\\"left\\\" colspan=\\\"\" + cols / 2 + \"\\\" bordercolor=\\\"#333333\\\" style=\\\"border-width:1px;border-style:solid;font-size:larger;\\\"&gt;日期：\" + DateTime.Now.ToShortDateString() + \"&lt;/th&gt;&lt;th colspan=\\\"\" + (cols - (cols / 2)) + \"\\\" bordercolor=\\\"#333333\\\" align=\\\"right\\\" style=\\\"border-width:1px;border-style:solid;font-size:larger;\\\"&gt;&lt;/th&gt;&lt;/tr&gt;\"; string temp3 = sArray[0] + tableline + sArray[1]; //tablehtml[\"htmltable\"] = temp3; tablehtml.Set(\"htmltable\", temp3); Session[\"htmltable\"] = temp3; &#125; &#125; // 4. 打印protected void createExcel_Click(object sender, EventArgs e) &#123; string filename = TableName; HttpContext context = HttpContext.Current; context.Response.Clear(); context.Response.Buffer = true; context.Response.Charset = \"gb2312\"; context.Response.AppendHeader(\"Content-Disposition\", \"attachment;filename=\" + filename + \".xls\"); context.Response.ContentEncoding = System.Text.Encoding.UTF8; context.Response.ContentType = \"application/vnd.ms-excel\"; context.Response.Write(\"&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=Content-Type content=\\\"text/html; charset=utf-8\\\"&gt;\"); context.Response.Write(Session[\"htmltable\"]); context.Response.Write(\"&lt;/body&gt;&lt;/html&gt;\"); Session[\"htmltable\"] = \"\"; context.Response.End(); &#125; 项目安装 安装数据库 sql server 2014 安装 vs 2012 附加数据库 附加数据库前要先赋予当前用户数据库文件完全控制权限 具体在文件属性，安全，编辑，勾选完全控制权限 在数据库中选择数据库文件所在位置然后添加 安装 dev 插件 两个文件 一个破解文件 一个安装文件","categories":[],"tags":[{"name":"c#","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-08-03T12:54:41.693Z","updated":"2017-08-30T08:27:38.000Z","comments":true,"path":"2019/08/03/hello-world/","link":"","permalink":"http://yoursite.com/2019/08/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"常用语言辨识","slug":"2017111102","date":"2017-11-11T12:00:53.000Z","updated":"2017-11-11T04:03:38.000Z","comments":true,"path":"2017/11/11/2017111102/","link":"","permalink":"http://yoursite.com/2017/11/11/2017111102/","excerpt":"","text":"编程常用语言辨识 Python：一种发展时间很长的简单脚本语言。经常被用于数据科学和机器学习。同时也非常受服务器端）Web开发的欢迎（框架：Django，Flask，Web2py，Tornado）。 Python: an old simple scripting language. Very popular in data science and machine learning. Also quite popular for (server-side) web development (frameworks: Django, Flask, Web2py, Tornado). Ruby：另一种简单的脚本语言。用于服务器端。在Ruby on Rails网络框架出现，出乎意料地流行了一段时间（现在有点走下坡路），不是很受欢迎。 Ruby: another simple scripting language. Server side. Wasn’t very popular until the Ruby on Rails web framework came along and was unexpectedly very popular for a while (now fading a bit). Java：使用非常广泛的编程语言。主要用在服务器端（J2EE，Spring，一些其他），但也用于Android手机上的客户端。很多谷歌的代码是用Java编写的 Java: very widely used programming language. Mainly server side (J2EE, Spring, some others) but is also used for client-side on Android phones. Considered by many to be clunky and cumbersome to write but very solid runtime (scaling, concurrency, etc). A lot of Google’s code is in Java. Javascript：在浏览器中使用的客户端编程语言。目前世界上最流行的语言，这主要是因为Node.js的快速上升，Node.js是服务器上的javascript。 Javascript: client-side programming language, used in browsers. the most popular language in the world at the moment, mainly because of the rapid rise of Node.js, which is javascript on the server. C：非常古老和尊敬的语言。 很难被掌握。Windows和Office构建在C和C ++（稍后面向对象的C版本）的组合上。 如果写得正确，二进制文件可能是世界上所有编译语言中性能最好的。 C: Very old and respected language. Windows and Office are built on a combination of C and C++ (a later object-oriented version of C). If written properly, the binaries have probably the best performance of any compiled language in the world. Considered extremely difficult to master. Scala：一种“功能”编程语言，用于编译JVM（Java虚拟机）的运行的字节码。开始变得相当受欢迎。 Scala: A “functional” programming language that compiles to bytecode that runs of the JVM (Java Virtual Machine). Starting to become quite popular. PHP：运行世界上大多数Web应用程序的服务器端语言。被很多人讨厌。 PHP: A server-side language that runs most of the world’s web applications. Hated by many people. .NET：这不是一种编程语言，它是一个应用程序框架。它通常运行用C＃编写的程序，但并不总是这样。 .NET: this is NOT a programming language, it is an application framework. It usually runs programs that were written in C# but that is not always the case.","categories":[],"tags":[{"name":"thought","slug":"thought","permalink":"http://yoursite.com/tags/thought/"}]},{"title":"计算机网络基础知识","slug":"2017111101","date":"2017-11-11T11:28:38.000Z","updated":"2017-11-11T03:59:24.000Z","comments":true,"path":"2017/11/11/2017111101/","link":"","permalink":"http://yoursite.com/2017/11/11/2017111101/","excerpt":"","text":"计算机网络概述学习计算机网络就是学习计算机网络模型中的网络协议 网络模型 OSI七层模型 物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 TCP/IP四层协议 网络接口层、 网际层、运输层、 应用层。 TCP/IP五层协议 物理层、数据链路层、网络层、运输层、 应用层。 OSI七层模型 物理层 物理层处于OSI的最底层，是整个开放系统的基础。物理层涉及通信信道上传输的原始比特流(bits)，它的功能主要是为数据端设备提供传送数据的通路以及传输数据 简单的说，物理层确保原始的数据可在各种物理媒体上传输。物理层记住两个重要的设备名称，中继器（Repeater，也叫放大器）和集线器。 数据链路层 数据链路层的主要任务是实现计算机网络中相邻节点之间的可靠传输，把原始的、有差错的物理传输线路加上数据链路协议以后，构成逻辑上可靠的数据链路。需要完成的功能有链路管理、成帧、差错控制以及流量控制等。其中成帧是对物理层的原始比特流进行界定，数据链路层也能够对帧的丢失进行处理。 数据链路层为网络层提供可靠的数据传输 基本数据单位为帧； 主要的协议：以太网协议； 两个重要设备名称：网桥和交换机。 网络层 网络层涉及源主机节点到目的主机节点之间可靠的网络传输，它需要完成的功能主要包括路由选择、网络寻址、流量控制、拥塞控制、网络互连等。 网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能 基本数据单位为IP数据报 包含的主要协议： IP协议（Internet Protocol，因特网互联协议） ICMP协议（Internet Control Message Protocol，因特网控制报文协议） ARP协议（Address Resolution Protocol，地址解析协议） RARP协议（Reverse Address Resolution Protocol，逆地址解析协议） 重要的设备：路由器。 传输层 传输层起着承上启下的作用，涉及源端节点到目的端节点之间可靠的信息传输。传输层需要解决跨越网络连接的建立和释放，对底层不可靠的网络，建立连接时需要三次握手，释放连接时需要四次挥手。 传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题 包含的主要协议： TCP协议（Transmission Control Protocol，传输控制协议） UDP协议（User Datagram Protocol，用户数据报协议） 重要设备：网关 会话层、表示层、应用层 会话层的主要功能是负责应用程序之间建立、维持和中断会话，同时也提供对设备和结点之间的会话控制，协调系统和服务之间的交流，并通过提供单工、半双工和全双工3种不同的通信方式，使系统和服务之间有序地进行通信。 表示层关心所传输数据信息的格式定义，其主要功能是把应用层提供的信息变换为能够共同理解的形式，提供字符代码、数据格式、控制信息格式、加密等的统一表示。 应用层为OSI的最高层，是直接为应用进程提供服务的。其作用是在实现多个系统应用进程相互通信的同时，完成一系列业务处理所需的服务。 数据传输基本单位为报文 包含的主要协议 FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议） SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol） TCP/IP 模型 网络接口层 TCP/IP协议对网络接口层没有给出具体的描述，网络接口层对应着物理层和数据链路层。 网际层 互联网层是整个TCP/IP协议栈的核心。它的功能是把分组发往目标网络或主机。同时，为了尽快地发送分组，可能需要沿不同的路径同时进行分组传递。因此，分组到达的顺序和发送的顺序可能不同，这就需要上层必须对分组进行排序。互联网层除了需要完成路由的功能外，也可以完成将不同类型的网络（异构网）互连的任务。除此之外，互联网层还需要完成拥塞控制的功能 运输层 TCP层负责在应用进程之间建立端到端的连接和可靠通信，它只存在与端节点中。TCP层涉及两个协议，TCP和UDP。其中，TCP协议提供面向连接的服务，提供按字节流的有序、可靠传输，可以实现连接管理、差错控制、流量控制、拥塞控制等。UDP协议提供无连接的服务，用于不需要或无法实现面向连接的网络应用中。 应用层 应用层为Internet中的各种网络应用提供服务 交换机 在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背 部总线上，当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部 交换矩阵迅速将数据包传送到目的端口。目的MAC若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表 中。 交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张 ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不 能划分网络层广播，即广播域。 交换机被广泛应用于二层网络交换，俗称“二层交换机”。 交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在OSI七层模型中的第二层、第三层、第四层盒第七层，并因此而得名。 路由器 路由器（Router）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。 路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。 路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。 网关 网关（Gateway），网关顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP/IP 的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家 庭中或者小型企业网络中使用，用于连接局域网和Internet。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。 在传统TCP/IP术语中，网络设备只分成两种，一种为网关（gateway），另一种为主机（host）。网关能在网络间转递数据包，但主机不能 转送数据包。在主机（又称终端系统，end system）中，数据包需经过TCP/IP四层协议处理，但是在网关（又称中介系 统，intermediate system）只需要到达网际层（Internet layer），决定路径之后就可以转送。在当时，网关 （gateway）与路由器（router）还没有区别。 在现代网络术语中，网关（gateway）与路由器（router）的定义不同。网关（gateway）能在不同协议间移动数据，而路由器（router）是在不同网络间移动数据，相当于传统所说的IP网关（IP gateway）。 网关是连接两个网络的设备，对于语音网关来说，他可以连接PSTN网络和以太网，这就相当于VOIP，把不同电话中的模拟信号通过网关而转换成数字信号，而且加入协议再去传输。在到了接收端的时候再通过网关还原成模拟的电话信号，最后才能在电话机上听到。 对于以太网中的网关只能转发三层以上数据包，这一点和路由是一样的。而不同的是网关中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。 网络协议 每一层的协议如下 物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器） 数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机） 网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器） 传输层：TCP、UDP、SPX 会话层：NFS、SQL、NETBIOS、RPC 表示层：JPEG、MPEG、ASII 应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS 每一层的作用如下 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit） 数据链路层：将比特组装成帧和点到点的传递（帧Frame） 网络层：负责数据包从源到宿的传递和网际互连（包PackeT） 传输层：提供端到端的可靠报文传递和错误恢复（段Segment） 会话层：建立、管理和终止会话（会话协议数据单元SPDU） 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU） 应用层：允许访问OSI环境的手段（应用协议数据单元APDU） ICMP协议因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。 TFTP协议是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。 HTTP协议超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。 DHCP协议动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。 NAT协议网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术。 DHCP协议一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。 ARP(地址解析协议)简单语言解释一下工作原理。 1：首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。 2：当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。 3：当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。 4：源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。广播发送ARP请求，单播发送ARP响应。 RARP协议RARP是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。 工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。 TCP/IP协议TCP/IP协议是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。 IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层—TCP或UDP层；相反，IP层也把从TCP或UDP层接收来的数据包传送到更低层。IP数据包是不可靠的，因为IP并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏，IP数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）。 TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接的所以只能用于端到端的通讯。TCP提供的是一种可靠的数据流服务，采用“带重传的肯定确认”技术来实现传输的可靠性。TCP还采用一种称为“滑动窗口”的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。 TCP对应的协议和UDP对应的协议TCP对应的协议： FTP：定义了文件传输协议，使用21端口。 Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。 SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。 POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。 HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。 UDP对应的协议： DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。 TFTP(Trival File Tran敏感词er Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。 TCP和UDP的区别 TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。 TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报。 TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般 TCP三次握手和四次挥手的全过程三次握手： 第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。 四次挥手： 与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。 DNS域名系统工作原理。当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括三条信息：包括：指定的DNS域名，指定的查询类型，DNS域名的指定类别。基于UDP服务，端口53. 该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。 在浏览器中输入www.baidu.com后执行的全部过程 客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。 在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。 客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。 客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。 HTTPS和HTTP的区别 HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。 https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。 超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如信用卡号、密码等。 为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 HTTPS和HTTP的区别主要为以下四点： https协议需要到ca申请证书，一般免费证书很少，需要交费。 http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 IP地址 网络地址 IP地址由网络号（包括子网号）和主机号组成，网络地址的主机号为全0，网络地址代表着整个网络。 广播地址 广播地址通常称为直接广播地址，是为了区分受限广播地址。广播地址与网络地址的主机号正好相反，广播地址中，主机号为全1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。 组播地址 D类地址就是组播地址。 A，B，C，D类地址 A类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255; B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255; C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255。 D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）； E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。 注：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。 255.255.255.255 该IP地址指的是受限的广播地址。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报，则不能收到。 注：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。 0.0.0.0 常用于寻找自己的IP地址，例如在我们的RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。 回环地址 127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1。 A、B、C类私有地址 私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。 A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255 B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255 C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255 子网掩码 子网掩码是标志两个IP地址是否同属于一个子网的，也是32位二进制地址，其每一个为1代表该位是网络位，为0代表主机位。它和IP地址一样也是使用点式十进制来表示的。如果两个IP地址在子网掩码的按位与的计算下所得结果相同，即表明它们共属于同一子网中。 在计算子网掩码时，我们要注意IP地址中的保留地址，即“ 0”地址和广播地址，它们是指主机地址或网络地址全为“ 0”或“ 1”时的IP地址，它们代表着本网络地址和广播地址，一般是不能被计算在内的。 IPv4与IPv6 目前的全球因特网所采用的协议族是TCP/IP协议族。IP是TCP/IP协议族中网络层的协议，是TCP/IP协议族的核心协议。目前IP协议的版本号是4(简称为IPv4)，发展至今已经使用了30多年。IPv4的地址位数为32位，也就是最多有2的32次方的电脑可以联到Internet上。 什么是IPv6IPv6是下一版本的互联网协议，也可以说是下一代互联网的协议，它的提出最初是因为随着互联网的迅速发展，IPv4定义的有限地址空间将被耗尽，地址空间的不足必将妨碍互联网的进一步发展。为了扩大地址空间，拟通过IPv6重新定义地址空间。IPv6采用128位地址长度，几乎可以不受限制地提供地址。按保守方法估算IPv6实际可分配的地址，整个地球的每平方米面积上仍可分配1000多个地址。在IPv6的设计过程中除了一劳永逸地解决了地址短缺问题以外，还考虑了在IPv4中解决不好的其它问题，主要有端到端IP连接、服务质量（QoS）、安全性、多播、移动性、即插即用等。 IPv6与IPv4相比有什么特点和优点 更大的地址空间。IPv4中规定IP地址长度为32，即有2^32-1个地址；而IPv6中IP地址的长度为128，即有2^128-1个地址。 更小的路由表。IPv6的地址分配一开始就遵循聚类(Aggregation)的原则，这使得路由器能在路由表中用一条记录(Entry)表示一片子网，大大减小了路由器中路由表的长度，提高了路由器转发数据包的速度。 增强的组播(Multicast)支持以及对流的支持(Flow-control)。这使得网络上的多媒体应用有了长足发展的机会，为服务质量(QoS)控制提供了良好的网络平台. 加入了对自动配置(Auto-configuration)的支持。这是对DHCP协议的改进和扩展，使得网络(尤其是局域网)的管理更加方便和快捷 更高的安全性.在使用IPv6网络中用户可以对网络层的数据进行加密并对IP报文进行校验,这极大的增强了网络安全","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"}]},{"title":"常用linux命令汇总","slug":"20171111005","date":"2017-11-10T14:11:05.000Z","updated":"2017-11-10T06:26:18.000Z","comments":true,"path":"2017/11/10/20171111005/","link":"","permalink":"http://yoursite.com/2017/11/10/20171111005/","excerpt":"","text":"常用 linux 命令汇总常用linux命令汇总apt-get 使软件包列表更新到最新 apt-get update 更新所有已安装的软件包： apt-get upgrade 安装一个新软件包： apt-get install packagename sudo dpkg -i 软件包名.deb 卸载一个已安装的软件包（保留配置文件） apt-get remove packagename 卸载一个已安装的软件包（删除配置文件） apt-get –purge remove packagename 将系统升级到新版本： apt-get dist-upgrade 添加软件源 add-apt-repository ppa:qbittorrent-team/qbittorrent-stable 下载Wget 普通下载12345678910111213141516wget http://www.sample-videos.com/video/mp4/720/big_buck_bunny_720p_1mb.mp4后台下载wget -b http://www.sample-videos.com/video/mp4/720/big_buck_bunny_720p_1mb.mp4ftp下载wget --ftp-user=&lt;user_name&gt; --ftp-password=&lt;Give_password&gt; Download-url-addressCurl借助-o选项，提供名称，下载文件会以该名称保存如使用-O选项，文件就会以原始名称保存。curl -o um.mp4 http://www.sample-videos.com/video/mp4/720/big_buck_bunny_720p_1mb.mp4curl -O http://www.sample-videos.com/video/mp4/720/big_buck_bunny_720p_1mb.mp4 解压缩 .tar 解包：tar xvf FileName.tar 打包：tar cvf FileName.tar DirName（注：tar是打包，不是压缩！） .gz 解压1：gunzip FileName.gz 解压2：gzip -d FileName.gz 压缩：gzip FileName .tar.gz 和 .tgz 解压：tar zxvf FileName.tar.gz 压缩：tar zcvf FileName.tar.gz DirName .bz2 解压1：bzip2 -d FileName.bz2 解压2：bunzip2 FileName.bz2 压缩：bzip2 -z FileName .tar.bz2 解压：tar jxvf FileName.tar.bz2 压缩：tar jcvf FileName.tar.bz2 DirName .bz 解压1：bzip2 -d FileName.bz 解压2：bunzip2 FileName.bz 压缩：未知 .tar.bz 解压：tar jxvf FileName.tar.bz 压缩：未知 .Z 解压：uncompress FileName.Z 压缩：compress FileName tar.Z 解压：tar Zxvf FileName.tar.Z 压缩：tar Zcvf FileName.tar.Z DirName .zip 解压：unzip FileName.zip 压缩：zip FileName.zip DirName .rar 解压：rar x FileName.rar 压缩：rar a FileName.rar DirName .lha 解压：lha -e FileName.lha 压缩：lha -a FileName.lha FileName .rpm 解包：rpm2cpio FileName.rpm | cpio -div .deb 解包：ar p FileName.deb data.tar.gz | tar zxf - 文件操作 命令 1:mkdir 用途:创建目录 实例 1: mkdir do 含义:在当前目录下创建名为 do 的子目录 命令 2:rmdir 用途:删除目录 实例 1: rmdir tmp 含义:删除当前目录下名为 tmp 的子目录,该子目录中没有文件和子目录 命令 3:cd 用途:改变目录 实例 1: cd 含义:回到用户主目录,即登录时进入的目录 实例 2: cd ../do/align 含义:进入上级目录 do 下的 align 子目录 命令 4:ls 用途:显示文件或目录 实例 1: ls 含义:显示当前目录下子目录和文件名 实例 2: ls -l 含义:显示当前目录下子目录和文件名详细信息,包括属性、权限、大小和创建日期等 命令 5:cat 用途:显示或编辑文本文件 实例 1: cat &gt; cat1 含义:往 cat1 中逐行输入文本,用 Ctrl-D 结束输入 实例 2: cat &gt;&gt; cat1 含义:往 cat1 中逐行追加文本,用 Ctrl-D 结束输入 实例 3: cat cat1 含义:显示文本文件 cat1 中的内容 命令 6:less 用途:显示文件内容 实例 1: less 209hba.list 含义:逐屏显示文件 209hba.list 内容,回车进一行,空格进一页,q 终止显示 命令 7:cp 用途：复制文件 实例 1: cp seq1 seq2 含义:将文件 seq1 复制到文件 seq2 中,保留qbittorrent seq1 实例 2: cp *.fasta ../keep/ 含义:将所有文件名以.fasta 结尾的文件复制到上级目录的 keep 子目录中 实例 3: cp ../seq/hba_human.sw . 含义:将上级目录的 seq 子目录中名为 hba_human.sw 的文件复制到当前目录中 实例4: cp /tmp/tf/zmtf-pep.fasta blast/ 含义:将/tmp 目录中 tf 子目录中名为 zmtf-pep.fasta 的文件复制到当前目录中名为blast 的子目录中 命令 8:mv 用途: 实例 1: mv seq1 seq2 含义:将文件 seq1 改名为 seq2,不保留 seq1 实例 2: mv hba_human.fasta pku08s1/hba 含义: 将当前目录下文件 hba_human.fasta 移到子目录 pku08s1 下的子目录hba 中 命令 9:rm 用途:删除文件或目录 实例 1: rm seq2 含义: 删除文件 seq2 实例 2: rm *.txt 含义: 删除所有以.txt 结尾的文件 实例 3: rm –r temp/* 含义: 删除子目录 temp 下所有子目录和文件,保留该目录 实例 4: rm –r temp 含义: 删除子目录 temp 和该目录下所有子目录和文件 命令 10:chmod 用途:改变文件或目录权限 实例 1: chmod –w ppf1.fas 含义:取消所有用户对 ppf1.fas 的写权限 实例 2: chmod +w seq1 含义:将当前目录下 seq1 设置为本用户可写,其他用户权限不变 实例 3: chmod -w keep/ 含义:取消子目录 keep 写权限,不能在该目录下创建和删除文件或子目录 实例 4: chmod 755 bin/* 含义:将子目录 bin 下所有文件设置为本用户可读可写可执行,其它用户可读可执行 命令 11:touch 用途：新建文件","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"linux 分区简介","slug":"20171111004","date":"2017-11-10T14:05:10.000Z","updated":"2017-11-11T04:21:12.000Z","comments":true,"path":"2017/11/10/20171111004/","link":"","permalink":"http://yoursite.com/2017/11/10/20171111004/","excerpt":"","text":"linux 分区简介初识 linux 之 linux 分区介绍分区方案 建议先分/和swap，然后把所有剩余空间分给/home swap ：交换分区，也是一种文件系统，它的作用是作为Linux的虚拟内存。 / ：根目录 ——— 所有目录挂在其下；Linux和UNIX的文件系统是一个以“/ “为根的阶层式的树状文件结构，/ 因此被称为根目录。所有的文件和目录都置于根目录/ 之下。 /home ：存放普通用户的数据，是普通用户的宿主目录，分区剩下的空间可以全部给它。 挂载 ：在windows操作系统中， 挂载通常是指给磁盘分区（包括被虚拟出来的磁盘分区）分配一个盘符。 第三方软件，如磁盘分区管理软件、虚拟磁盘软件等，通常也附带挂载功能。 在linux操作系统中， 挂载是指将一个设备（通常是存储设备）挂接到一个已存在的目录上。 我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上， 然后通过访问这个目录来访问存储设备。 分区介绍 FHS标准：它定义了如下的内容。 定义了文件系统中每个区域的用途 定义了所需要的最小构成的文件和目录 给出了例外处理和矛盾的特殊例子 /boot ——— 存放Ubuntu内核和系统启动文件。系统启动时这些文件先被装载。 /etc ——— 系统的配置文件目录。密码文件、设置网卡信息、环境变量的设置等都在此目录中，许多网络配置文件也在其中。 /lib ——— 根文件系统目录下程序和核心模块的共享库。这个目录里存放着系统最基本的动态链接共享库，类似于Windows下的system32目录，几乎所有的应用程序都需要用到这些共享库。 /media ——— 主要用于挂载多媒体设备。ubuntu系统自动挂载的光驱、usb设备，存放临时读入的文件。 /proc ——— 这个目录是系统内存的映射，我们可以直接访问这个目录来获取系统信息。也就是说，这个目录的内容不在硬盘上而是在内存里。 /sbin ——— s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序，如系统管理、目录查询等关键命令文件。 /tmp ——— 这个目录是用来存放一些临时文件的，所有用户对此目录都有读写权限。 /home ——— 用户的主目录。下面是自己定义的用户名的文件夹。每个用户的设置文件，用户的桌面文件夹，还有用户的数据都放在这里。 /mnt ——— 此目录主要是作为挂载点使用。通常包括系统引导后被挂载的文件系统的挂载点。如挂载Windows下的某个分区。 /root ——— 系统管理员（超级用户），即根用户的主目录。 /srv ——— 存储系统提供的服务数据。 /usr ——— 包括与系统用户直接有关的文件和目录。 /usr/X11R6 存放X-Windows的目录； /usr/games 存放着XteamLinux自带的小游戏； /usr/bin 用户和管理员的标准命令； /usr/sbin 存放root超级用户使用的管理程序； /usr/doc Linux技术文档； /usr/include 来存放Linux下开发和编译应用程序所需要的头 文件，for c 或者c++； /usr/lib 应用程序和程序包的连接库； /usr/local 系统管理员安装的应用程序目录； /usr/man 帮助文档所在的目录； /usr/src Linux开放的源代码； /usr/share 用于存放一些共享的数据，比如音乐文件或者图 标等等 /var ——— 用于存放很多不断变化的文件，例如日志文件等。包含了日志文件、计划性任务和邮件等内容。 /var/cache 应用程序缓存目录； /var/crash 系统错误信息； /var/games 游戏数据； /var/log 日志文件； /var/mail 电子邮件； /var/tmp 临时文件目录； /bin ———bin是binary的缩写。这个目录沿袭了UNIX系统的结构，存放着使用者最经常使用的命令。例如cp、ls、cat，等等。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Markdown","slug":"20171111003","date":"2017-11-10T13:57:04.000Z","updated":"2017-11-10T06:12:26.000Z","comments":true,"path":"2017/11/10/20171111003/","link":"","permalink":"http://yoursite.com/2017/11/10/20171111003/","excerpt":"","text":"Markdown Markdown简单的来说就是一种书写语言，能够帮助你更容易的在电脑上书写你的文章（主要针对对于HTML基础薄弱的人）。简而言之，使用markdown能够是你事半功倍。 写这篇文章的目的是对自己对markdown语法的练习。所有内容均是于这里所学习而来 下面记录一下markdown的主要语法，以便记忆。 标题 标题有两种使用方法 1234This is an H1=============This is an H2-------------- 任何数量的 = 和 - 都可以有效果, 另外一种是 123＃这是 H1＃这是 H2＃这是 H3 区块引用 This is a blockquote with two paragraphs. Lorem ipsum dolor sitemamet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.区块引用是下面这样的形式。注意区块引用可以嵌套,markdown语法在区块内依旧起作用。 This is a blockquote with two paragraphs. Lorem ipsum dolor sitemamet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. 列表 1234+ Red- Red* Red3. Red 代码区块 如果你想成为一名程序猿，代码区块可以展示你的代码，上面所展示的框框均为代码区块 1sudo apt-get -f install 代码 代码区块主要在添加大段代码时使用，如果你只是想使用很短的代码，则可以使用代码语法(反引号在键盘１的左边） sudo apt-get -f install 分隔线 12`* * * - - -` 强调 斜体 *single asterisks* _single underscores_ 粗体 **double asterisks** __double underscores__ 图片 ![Alt text](url)","categories":[],"tags":[{"name":"thought","slug":"thought","permalink":"http://yoursite.com/tags/thought/"}]},{"title":"路由刷机","slug":"20171111002","date":"2017-11-10T13:54:13.000Z","updated":"2017-11-11T04:20:52.000Z","comments":true,"path":"2017/11/10/20171111002/","link":"","permalink":"http://yoursite.com/2017/11/10/20171111002/","excerpt":"","text":"k2路由器刷机操作１．降级固件首先要对 k2 进行降级操作，只有旧版的才可以刷入 breed 和 ssh 在系统设置里选择手动升级下载并选择这个旧版本固件 ２．刷入 breed 和 ssh首先下载解压这个文件 依次选择系统设置－恢复备份，选择该文件恢复即可。 之后记得在手动升级界面下选择备份EEPROM（买份保险oO)。 ３．刷入第三方固件在恩山无线论坛有很多第三方固件，你可以选择自己所喜欢的来刷入 这里提供两种：华硕和潘多拉 潘多拉本地网址：１９２．１６８．１．１ 用户名：root 密码：admin 华硕本地网址：１９２．１６８．１２３．１ 用户名和密码 admin 刷入方法 介绍一种可以在上述两种固件之间通刷的方法 断电，按着reset键不松手，然后通电１０秒后松开reset键。 等待一分钟后即可进入 breed 恢复控制台（地址：１９２．１６８．１．１） 在 breed 控制台中恢复出厂设置 接下来在固件更新中选择你想刷入的固件即可","categories":[],"tags":[{"name":"router","slug":"router","permalink":"http://yoursite.com/tags/router/"}]},{"title":"EF","slug":"20171111001","date":"2017-11-10T13:47:25.000Z","updated":"2017-11-10T05:49:14.000Z","comments":true,"path":"2017/11/10/20171111001/","link":"","permalink":"http://yoursite.com/2017/11/10/20171111001/","excerpt":"","text":"EFcode first 引入 Entity Framework Core 创建实体 类，DBContext 创建数据库连接 var connection = &quot; Filename=./database.db&quot;; services.AddDbContext&lt;nameforContext&gt;(option s =&gt; options.UseSqlServer(connection) ) 使用时要先对DBContext 进行实例化 创建数据库 dotnet ef migrations add MyFirstMigration dotnet ef database update Database First 引入 Entity Framework Core 生成实体 dotnet ef dbcontext scaffold&quot;FileName=sample.db&quot;Microsoft.EntityFrameworkCoreSqlServer -OutputDir Models Server=.;Database=DatabaseName;UID=sa;PWD= 项目使用 在startup.cs 中添加 DbContext dotnet 命令 命令 函数 dotnet build 生成 .NET Core 应用程序。 dotnet clean 清除生成输出。 dotnet help 显示命令更详细的在线文档。 dotnet migrate 将有效的预览版 2 项目迁移到 .NET Core SDK 1.0 项目。 dotnet msbuild 提供对 MSBuild 命令行的访问权限。 dotnet new 为给定的模板初始化 C# 或 F # 项目。 dotnet pack 创建代码的 NuGet 包。 dotnet publish 发布 .NET 依赖于框架或独立应用程序。 dotnet restore 还原给定应用程序的依赖项。 dotnet run 从源运行应用程序。 dotnet sln 用于添加、删除和列出解决方案文件中项目的选项。 dotnet store 将程序集存储到运行时包存储区。 dotnet test 使用测试运行程序运行测试。 dotnet add reference 添加项目引用。 dotnet list reference 列出项目引用。 dotnet remove reference 删除项目引用。 dotnet add package 添加 NuGet 包。 dotnet remove package 删除 NuGet 包。 Lambda expression 表达式 简化类内的方法数量，提升可维护性 表达式型 表达式只有一行时可以使用 12345678910(input parameters) =&gt; expression单一参数可以省略小括号：o =&gt; o+1两个以上参数：(a,b) =&gt; a+b无参数：() =&gt; 3 语句型 表达式有多行时选择语句型 1( input parameters ) =&gt; &#123; statements; &#125; 异步型 表达式用于异步操作时 123声明时，加上 asyncasync ( input parameters ) =&gt; &#123; await statements; &#125;在表达式内部用到其他异步方法时加上 await 指令 linq to Entity使用LINQ to Entities操作实体 编写LINQ查询的方式有两种： 查询语法 方法语法 实例 查询 找出打赏了50元的用户 查询语法123var donators = from donator in db.Donatorswhere donator.Amount == 50mselect donator; - 方法语法 1var donators = db.Donators.Where(d =&gt; d.Amount == 50m); 简单查询 123456//1.查询语法var donators = from donator in db.Donators select donator;//2.方法语法var donators = db.Donators; 3.复杂查询 获取山东省的所有打赏者 1234567891011#region 2.0 使用导航属性//1 查询语法var donators = from province in db.Provinces where province.ProvinceName == \"山东省\" from donator in province.Donators select donator;//2 方法语法var donators = db.Provinces.Where(p =&gt; p.ProvinceName == \"山东省\").SelectMany(p =&gt; p.Donators);#endregio 获取打赏者“雪茄”的省份： 1234567//1 查询语法//var province = from donator in db.Donators// where donator.Name == \"雪茄\"// select donator.Province;//2 方法语法var province = db.Donators.Where(d =&gt; d.Name == \"雪茄\").Select(d =&gt; d.Province); 过滤数据 在10~20元之间的用户 12345678910#region 3.0 过滤数据//1 查询语法var donators = from donator in db.Donators where donator.Amount &gt; 10 &amp;&amp; donator.Amount &lt; 20 select donator;//2 方法语法var donators = db.Donators.Where(d =&gt; d.Amount &gt; 10 &amp;&amp; d.Amount &lt; 20);#endregio 复杂查询 所有省份的打赏者 123456789101112131415161718192021222324//1 查询语法var donators = from province in db.Provinces select new &#123; Province=province.ProvinceName, DonatorList=province.Donators &#125;;//2 方法语法var donators =db.Provinces.Select(p=&gt;new&#123; Province = p.ProvinceName, DonatorList = p.Donators&#125;);Console.WriteLine(\"省份\\t打赏者\");foreach (var donator in donators)&#123; foreach (var donator1 in donator.DonatorList) &#123; Console.WriteLine(\"&#123;0&#125;\\t&#123;1&#125;\", donator.Province,donator1.Name); &#125; &#125;#endregion 增加 12345678910111213# 方法一using (var db=new DonatorsContext())&#123; db.Provinces.Add(province); db.SaveChanges();&#125;# 方法二 using (var db=new DonatorsContext()) &#123; db.Entry(province2).State=EntityState.Added; db.SaveChanges(); &#125; 状态 描述 Added 添加了一个新的实体。该状态会导致一个插入操作。 Deleted 将一个实体标记为删除。设置该状态时，该实体会从DbSet中移除。该状态会导致删除操作。 Detached DbContext不再追踪该实体。 Modified 自从DbContext开始追踪该实体，该实体的一个或多个属性已经更改了。该状态会导致更新操作。 Unchanged 自从DbContext开始追踪该实体以来，它的任何属性都没有改变。 更新 12345678910111213using (var db=new DonatorsContext())&#123; var donator = db.Donators.Find(3); //db.Donators.Attach(donator); db.Entry(donator).State=EntityState.Modified;//这句可以作为第二种方法替换上面一句代码 //donator.Name = \"醉千秋\"; //foreach (var donator in province.Donators) &#123; db.Entry(donator).State=EntityState.Modified; &#125; db.SaveChanges();&#125; 删除 1234foreach (var donator in province.Donators) &#123; db.Entry(donator).State=EntityState.Modified; &#125; 1234567Movie movie = db.Movies.Find(id); db.Movies.Remove(movie); db.SaveChanges(); return RedirectToAction(\"Index\");删除多个RemoveRange 理解 当使用LINQ to Entities时，理解何时使用IEnumerable和IQueryable很重要。如果使用了IEnumerable，查询会立即执行，如果使用了IQueryable，直到应用程序请求查询结果的枚举时才会执行查询，也就是查询延迟执行了，延迟到的时间点是枚举查询结果时。如何决定使用IEnumerable还是IQueryable呢？使用IQueryable会让你有机会创建一个使用多条语句的复杂LINQ查询，而不需要每条查询语句都对数据库执行查询。该查询只有在最终的LINQ查询要求枚举时才会执行 一般而言，输出类型是IQueryable类型，我们的例子中应该是IQueryable。当然我们也可以明确指定返回的类型为IQueryable或者IEnumerable","categories":[],"tags":[{"name":"Asp.net Mvc","slug":"Asp-net-Mvc","permalink":"http://yoursite.com/tags/Asp-net-Mvc/"}]},{"title":"c# helpers","slug":"20171110","date":"2017-11-10T13:43:01.000Z","updated":"2017-11-11T19:21:04.000Z","comments":true,"path":"2017/11/10/20171110/","link":"","permalink":"http://yoursite.com/2017/11/10/20171110/","excerpt":"","text":"helpersHtmlhelper ActionLink,RouteLink 超链接 12Html.ActionLink(\"这是一个连接\", \"Index\", \"Home\", new &#123; page = 1 &#125;, new &#123; id = \"link1\" &#125;) TextBox与TextArea TextBox Html.TextBox(&quot;input2&quot;,Model.CategoryName,new{ @style = &quot;width:300px;&quot; }) &lt;input id=&quot;input2&quot; name=&quot;input2&quot; style=&quot;width:300px;&quot; type=&quot;text&quot; value=&quot;Beverages&quot; /&gt; TextBoxFor(以强类型引用 model 属性 并经由 Lambda expression 的方式提供属性) TextArea Html.TextAreaFor(a =&gt; a.CategoryName, 3, 3, null) &lt;textarea cols=&quot;3&quot; id=&quot;CategoryName&quot; name=&quot;CategoryName&quot; rows=&quot;3&quot;&gt;Electronic&lt;/textarea&gt; DisplayNameFor 返回 model 中指定 Property 的名称 DisplayFor 返回 model 中指定 Property DisplayForModel 返回 mode\u0001l 中的每一个 Property Html.ValidationMessageFor 自行指定验证信息内容或使用默认的验证信息 是否符合格式 EditorFor 编辑框 LabelFor 文本 htmlhelper 使用HtmlHelper生成超链接: &lt;%=Html.ActionLink(&quot;我是超链接&quot;,&quot;&quot;) %&gt; 生成的结果： &lt;a href=&quot;/&quot;&gt;我是超链接&lt;/a&gt; 使用 HtmlHelper 生成表单: &lt;% Html.BeginForm(&quot;Index&quot;, &quot;Simple&quot;, FormMethod.Post, new { id = &quot;myForm&quot; }); %&gt; &lt;% Html.EndForm();%&gt; 12345678@using (Ajax.BeginForm(\"action\", \"controller\", null, new AjaxOptions &#123; UpdateTargetId = \"UserLogOnContainer\", HttpMethod = \"Post\", OnSuccess = \" \", &#125;)) &#123;&#125; //提交到指定controller下的action，提交方式为Post,异步更新模块ＩＤ为UserLogOnContainer 生成的结果： &lt;form action=&quot;/Index/Simple&quot; id=&quot;myForm&quot; method=&quot;post&quot;&gt;&lt;/form&gt; 使用 HtmlHelper 根据路由规则生成表单: 123&lt;% Html.BeginRouteForm(new &#123; controller = \"Simple\", action = \"Demo\" &#125;); %&gt;&lt;%Html.EndForm(); %&gt; 生成的结果： &lt;form action=&quot;/Simple/Demo&quot; method=&quot;post&quot;&gt;&lt;/form&gt; 使用HtmlHelper生成一个复选框： &lt;%= Html.CheckBox(&quot;checkBox&quot;,new { id=&quot;myCheckBox&quot; })%&gt;复选框 生成的结果： &lt;input id=&quot;myCheckBox&quot; name=&quot;checkBox&quot; type=&quot;checkbox&quot; value=&quot;true&quot; /&gt;&lt;input name=&quot;checkBox&quot; type=&quot;hidden&quot; value=&quot;false&quot; /&gt;复选框 使用HtmlHelper生成上拉列表框: 12345678910&lt;% var dropList = new List&lt;SelectListItem&gt;(); for (int i = 0; i &lt; 5; i++) &#123; var dropItem = new SelectListItem(); dropItem.Value = i.ToString(); dropItem.Text = i.ToString(); dropList.Add(dropItem); &#125; %&gt;&lt;%=Html.DropDownList(\"myList\", dropList, new &#123; style = \"width:100px;\" &#125;)%&gt; 生成的结果： 1234567891011121314151617&lt;select id=\"myList\" name=\"myList\" style=\"width:100px;\"&gt;&lt;option value=\"0\"&gt;0&lt;/option&gt;&lt;option value=\"1\"&gt;1&lt;/option&gt;&lt;option value=\"2\"&gt;2&lt;/option&gt;&lt;option value=\"3\"&gt;3&lt;/option&gt;&lt;option value=\"4\"&gt;4&lt;/option&gt;&lt;/select&gt;``` 6. 使用HtmlHelper生成隐藏域:`&lt;%=Html.Hidden(\"hidden\") %&gt;`生成的结果： `&lt;input id=\"hidden\" name=\"hidden\" type=\"hidden\" value=\"\" /&gt;`7. 使用HtmlHelper生成列表框： &lt;%var list = new List(); for (var i = 0; i &lt; 5; i++) { var item = new SelectListItem(); item.Value = i.ToString(); item.Text = i.ToString(); list.Add(item); } %&gt;&lt;%=Html.ListBox(“listBox”, list, new {style=”width:100px;” })%&gt; 12生成的结果： 0 1 2 3 4 123456789108. 使用HtmlHelper生成密码输入框:`&lt;%=Html.Password(\"password\",\"longgel\") %&gt;`生成的结果： `&lt;input id=\"password\" name=\"password\" type=\"password\" value=\"longgel\" /&gt;` 9. 使用HtmlHelper生成单选框: &lt;%=Html.RadioButton(“radio”,”boy”,true) %&gt;男&lt;%=Html.RadioButton(“radio”,”girl”,false) %&gt;女 12生成的结果： 男女 1234567891011121314151617181920212223242526272829303132333435363710. 使用HtmlHelper生成部分视图（用户控件）`&lt;% Html.RenderPartial(\"PartialView\"); %&gt;`生成的结果： `&lt;span style=\"background-color:Red\"&gt;Hi，我是部分视图（用户控件）&lt;/span&gt;`11. 使用HtmlHelper根据路由规则生成超链接：`&lt;%= Html.RouteLink(\"我是由路由生成的超链接\",new &#123;controller=\"Simple\",action=\"Index\"&#125;) %&gt;`生成的结果： `&lt;a href=\"/\"&gt;我是由路由生成的超链接&lt;/a&gt;`12. 使用HtmlHelper生成富文本框：`&lt;%=Html.TextArea(\"myTxtArea\",new&#123;style=\"width:300px; height:100px;\"&#125;) %&gt;`生成的结果： `&lt;textarea cols=\"20\" id=\"myTxtArea\" name=\"myTxtArea\" rows=\"2\" style=\"width:300px; height:100px;\"&gt;&lt;/textarea&gt;` 13. 使用HtmlHelper生成文本框：`&lt;%=Html.TextBox(\"myTxtBox\",\"我是文本框\")%&gt;`生成的结果： `&lt;input id=\"myTxtBox\" name=\"myTxtBox\" type=\"text\" value=\"我是文本框\" /&gt;`## urlhelper1. 使用Action方法生成URL(Controller将是默认的) &lt;a href=&apos;&lt;%= Url.Action(&quot;DemoAction&quot;) %&gt;&apos; title=&quot;&quot;&gt;指定Action名称生成URL&lt;/a&gt; &lt;a href=&apos;&lt;%= Url.Action(&quot;DemoAction&quot;,&quot;id&quot;) %&gt;&apos; title=&quot;&quot;&gt;指定Action和一个RouteData(参数)生成URL&lt;/a&gt; &lt;a href=&apos;&lt;%= Url.Action(&quot;DemoAction&quot;, new {id=2,category=5 })%&gt;&apos; title=&quot;&quot;&gt;指定Action名称和多个参数生成URL&lt;/a&gt; &lt;a href=&apos;&lt;%= Url.Action(&quot;DemoAction&quot;,&quot;DemoController&quot;)%&gt;&apos; title=&quot;&quot;&gt;指定Action和Controller生成URL&lt;/a&gt; &lt;a href=&apos;&lt;%= Url.Action(&quot;DemoAction&quot;,&quot;DemoController&quot;,&quot;id&quot;)%&gt;&apos; title=&quot;&quot;&gt;指定Action,Controller和一个参数生成URL&lt;/a&gt; &lt;a href=&apos;&lt;%= Url.Action(&quot;DemoAction&quot;,&quot;DemoController&quot;, new {id=2,category=5 })%&gt;&apos; title=&quot;&quot;&gt;指定Action,Controller和多个参数生成URL&lt;/a&gt; &lt;a href=&apos;&lt;%= Url.Action(&quot;DemoAction&quot;,&quot;DemoController&quot;, new {id=2,category=5 },&quot;https&quot;)%&gt;&apos; title=&quot;&quot;&gt;指定传输协议生成URL&lt;/a&gt; &lt;% var rvd = new RouteValueDictionary(); rvd.Add(&quot;id&quot;, 5); rvd.Add(&quot;category&quot;, 2); var tmp = 5; %&gt; &lt;a href=&apos;&lt;%= Url.Action(&quot;DemoAction&quot;,&quot;DemoController&quot;, rvd,&quot;https&quot;,&quot;local&quot;)%&gt;&apos; title=&quot;&quot;&gt;指定主机名生成URL&lt;/a&gt; 生成的结果： 指定Action名称生成URL &lt;a href=&apos;/id/DemoAction&apos; title=&quot;&quot;&gt;指定Action和一个RouteData(参数)生成URL&lt;/a&gt; &lt;a href=&apos;/simple/DemoAction?id=2&amp;category=5&apos; title=&quot;&quot;&gt;指定Action名称和多个参数生成URL&lt;/a&gt; &lt;a href=&apos;/DemoController/DemoAction&apos; title=&quot;&quot;&gt;指定Action和Controller生成URL&lt;/a&gt; &lt;a href=&apos;/DemoController/DemoAction?Length=2&apos; title=&quot;&quot;&gt;指定Action,Controller和一个参数生成URL&lt;/a&gt; &lt;a href=&apos;/DemoController/DemoAction?id=2&amp;category=5&apos; title=&quot;&quot;&gt;指定Action,Controller和多个参数生成URL&lt;/a&gt; &lt;a href=&apos;https://localhost/DemoController/DemoAction?id=2&amp;category=5&apos; title=&quot;&quot;&gt;指定传输协议生成URL&lt;/a&gt; &lt;a href=&apos;https://local/DemoController/DemoAction?id=5&amp;category=2&apos; title=&quot;&quot;&gt;指定主机名生成URL&lt;/a&gt;122. 使用Content方法将虚拟(相对)路径生成为绝对路径 &lt;a href=&apos;&lt;%= Url.Content(&quot;~/DemoController/DemoAction&quot;)%&gt;&apos; title=&quot;&quot;&gt;指定虚拟路径生成绝对路径&lt;/a&gt;指定虚拟路径生成绝对路径 123. 使用Encode加密URL &lt;a href=&apos;&lt;%= Url.Encode(&quot;http://www.cnblogs.com/longgel/&quot;)%&gt;&apos; title=&quot;&quot;&gt;加密过的URL连接&lt;/a&gt; 生成的结果： &lt;a href=&apos;http%3a%2f%2fwww.cnblogs.com%2flonggel%2f&apos; title=&quot;&quot;&gt;加密过的URL连接&lt;/a&gt; 124. 使用RouteUrl生成URL &lt;a href=&apos;&lt;%= Url.RouteUrl(tmp)%&gt;&apos; title=&quot;&quot;&gt;指定RouteValue生成URL&lt;/a&gt; &lt;a href=&apos;&lt;%= Url.RouteUrl(&quot;Default&quot;)%&gt;&apos; title=&quot;&quot;&gt;指定RouteName生成URL&lt;/a&gt; &lt;a href=&apos;&lt;%= Url.RouteUrl(rvd)%&gt;&apos; title=&quot;&quot;&gt;指定多个参数生成URL&lt;/a&gt; &lt;a href=&apos;&lt;%= Url.RouteUrl(&quot;Default&quot;,tmp) %&gt;&apos; title=&quot;&quot;&gt;指定路由规则名和单个路由值&lt;/a&gt; &lt;a href=&apos;&lt;%= Url.RouteUrl(&quot;Default&quot;,rvd) %&gt;&apos; title=&quot;&quot;&gt;指定路由规则名和多个路由值&lt;/a&gt; &lt;a href=&apos;&lt;%= Url.RouteUrl(&quot;Default&quot;,tmp,&quot;https&quot;) %&gt;&apos; title=&quot;&quot;&gt;指定传输协议&lt;/a&gt; &lt;a href=&apos;&lt;%= Url.RouteUrl(&quot;Default&quot;,rvd,&quot;https&quot;,&quot;www.cnblogs.com&quot;) %&gt;&apos; title=&quot;&quot;&gt;指定主机名&lt;/a&gt; 生成的结果： &lt;a href=&apos;/simple/urlhelperdemo&apos; title=&quot;&quot;&gt;指定RouteValue生成URL&lt;/a&gt; &lt;a href=&apos;/Longgel/Index/Id&apos; title=&quot;&quot;&gt;指定RouteName生成URL&lt;/a&gt; &lt;a href=&apos;/simple/urlhelperdemo?id=5&amp;category=2&apos; title=&quot;&quot;&gt;指定多个参数生成URL&lt;/a&gt;&lt;br /&gt;/Longgel/Index/Id &lt;a href=&apos;/Longgel/Index/Id&apos; title=&quot;&quot;&gt;指定路由规则名和单个路由值&lt;/a&gt; &lt;a href=&apos;/Longgel/Index/Id?id=5&amp;category=2&apos; title=&quot;&quot;&gt;指定路由规则名和多个路由值&lt;/a&gt; &lt;a href=&apos;https://localhost/Longgel/Index/Id&apos; title=&quot;&quot;&gt;指定传输协议&lt;/a&gt; &lt;a href=&apos;https://www.cnblogs.com/Longgel/Index/Id?id=5&amp;category=2&apos; title=&quot;&quot;&gt;指定主机名&lt;/a&gt;``` AJAX HELP用法与 htmlhelp 相同 @Ajax.ActionLink","categories":[],"tags":[{"name":"Asp.net Mvc","slug":"Asp-net-Mvc","permalink":"http://yoursite.com/tags/Asp-net-Mvc/"}]},{"title":"c# controller","slug":"c-help","date":"2017-11-10T13:36:13.000Z","updated":"2017-11-11T19:24:26.000Z","comments":true,"path":"2017/11/10/c-help/","link":"","permalink":"http://yoursite.com/2017/11/10/c-help/","excerpt":"","text":"Controller数据传递ViewBag ViewData ViewBag＆的相似之处ViewData： 帮助您从控制器移动到查看时保持数据。 用于将数据从控制器传递到相应的视图。 寿命短意味着null重定向发生时的价值。这是因为他们的目标是提供一种在控制器和视图之间进行通信的方式。这是服务器调用中的通信机制。 ViewBag＆之间的区别ViewData： ViewData是dictionary从ViewDataDictionary类派生的对象，可以使用strings作为关键字来访问。 ViewBag 是一个动态属性，它利用了C＃4.0中的新动态特性。 ViewData需要对复杂数据类型进行类型转换，并检查null值以避免错误。 ViewBag 不需要对复杂数据类型进行类型转换。 用法 12345678910111213141516public ActionResult Index()&#123; ViewBag.Name = \"Monjurul Habib\"; return View();&#125;public ActionResult Index()&#123; ViewData[\"Name\"] = \"Monjurul Habib\"; return View();&#125; ## view@ViewBag.Name @ViewData[\"Name\"] TempDataTempData也是一个从TempDataDictionary类派生的字典，存储在short lives session中，它是一个字符串键和对象值。 不同之处在于对象的生命周期。 TempData保存HTTP请求的信息。 这只意味着从一个页面到另一个页面。 这也适用于302/303重定向，因为它在相同的HTTP请求中。 当您从一个控制器移动到另一个控制器或从一个操作移动到另一个操作时，它有助于保持数据。 换句话说，当您重定向时，“Tempdata”有助于维护这些重定向之间的数据。 它在内部使用会话变量。 当前和后续请求期间临时数据的使用仅意味着在确定下一个请求将重定向到下一个视图时使用它。 它需要对复杂数据类型进行类型转换，并检查空值以避免错误。 它通常用于存储一次性消息，如错误消息，验证消息。 多 model 传递 多 model 传递 var products = db.Products.Include(p =&gt; p.model1).Include( p=&gt; p.model2) return View(products.ToList()) SelectList 类 给 dropdownlist listboex 等列表使用 辅助类时必须通过 selectlist 类来封装 public SelectList(IEumerable items, string dataValueField,string dataTextField) viewModel @model 文件中只允许有一个 model 语句 viewModel 类 建立步骤 在Models 目录下新建 ViewModels 类 命名习惯： 传递对象名称 加上 ViewModel 结尾 在该类中定义你所需要的类和属性 ActionResult 每个 Controller 的 Action 方法操作完成后，最终结果一定要返回一个实现 ActionResult 抽象类的类型，返回类型最好使用 actionResult 继承自 ActionResult 类型 继承自 ActionResult 类型 Controller 方法 说明 ContentResult Content() 返回文字内容 FileResult File() 输出文件内容 HttpNotFoundResult HttpNotFound() 响应 HTTP 状态代码 JavaScriptResult JavaScript() 输出 JavaScript 内容 JsonResult Json() 输出 Json 内容 ViewResult View() 输出 Html 内容 PartialViewResult ParticalView() 输出部分 Html 内容 RedirectReslut Redirct() 进行 url 重定向 RedirectToRouteResult RedirectToAction() 使用路由系统进行 url 重定向 JsonResult列表化数据为 JSON 格式 return Json(person,JsonRequestBehavior.AllowGet) 接受 JSON 并列表化，接受到参数，返回return Json(person,JsonRequestBehavior.AllowGet) Action Filters 进入 Action 方法之前与离开 Action 方法之后进行的操作 Model BindingView向Controller中传递数据的方式 QueryString 123456789101112131415161718&lt;div&gt; &lt;button id=\"btn\"&gt;提交&lt;/button&gt;&lt;/div&gt;&lt;script&gt; $(function () &#123; $('#btn').click(function () &#123; //url不区分大小写 location.href = \"/home/getvalue?method=querystring\"; &#125;); &#125;);&lt;/script&gt;// controllerpublic void GetValue()&#123; //Request属性可用来获取querystring,form表单以及cookie中的值 var querystring = Request[\"method\"];&#125; RouteData &quot;/home/getvalue/100&quot; ModelBinding Model绑定体现在从当前请求提取相应的数据绑定到目标Action方法的同名参数（不区分大小写）中。对于这样的一个Action，如果是Post请求，MVC会尝试将Form（注意，这里的Form不是指html中的表单，而是Post方法发送数据的方式，若我们使用开发者工具查看Post方式发送的请求信息，会看到Form Data一栏）中的值赋值到Action参数中，如果是get请求，MVC会尝试将QueryString的值赋值到Action参数中 Form form表单形式是常见的向后端发送数据的方式，但是在提交数据时只会提交form表单内部具有name属性的input,textarea,select标签的value值 1234567891011121314&lt;form action=\"/home/getvalue\" method=\"post\"&gt; &lt;input type=\"text\" name=\"username\" /&gt; &lt;input type=\"text\" name=\"age\" /&gt; &lt;input type=\"submit\" name=\"button\" value=\"提交\" /&gt;&lt;/form&gt;// controllerpublic void GetValue()&#123; var name = Request[\"username\"]; var age = Request[\"age\"]; var btn = Request[\"button\"];&#125; 使用和Action参数同名的变量进行传递 123456789101112131415161718192021222324&lt;button id=\"btn\"&gt;传递数据&lt;/button&gt;&lt;script&gt; $(function () &#123; $('#btn').click(function () &#123; $.ajax(&#123; 'type': 'post', 'url': '/home/getdata', //传递的数据也可以是序列化之后的json格式数据 //如，上面使用form表单提交数据就可以使用jquery中的serialize()方法将表单进行序列化之后在提交 //data:$('#form').serialize() 'data': &#123; username: '雪飞鸿', age: '24' &#125;, error: function (message) &#123; alert('error!'); &#125; &#125;); &#125;) &#125;)&lt;/script&gt;// Controllerpublic void GetData(string username, int age)&#123;&#125; Cookie 这里引用jquery.cookie插件来进行cookie的操作 1234567891011121314151617181920&lt;body&gt; &lt;button id=\"btn\"&gt;提交&lt;/button&gt; &lt;script&gt; $(function () &#123; //向cookie中写入值 $.cookie('key', 'jscookie'); $('#btn').click(function () &#123; location.href = \"/home/getvalue\"; &#125;); &#125;) &lt;/script&gt;&lt;/body&gt;//Controllerpublic void GetValue()&#123; var cookie = Request[\"key\"];&#125; Controller向View中传值 Json 1234567891011121314151617181920212223242526272829public ActionResult Index()&#123; return View();&#125;public JsonResult SendData()&#123; return Json(new &#123; UserName = \"雪飞鸿\", Age = 24 &#125;);&#125;// view&lt;p id=\"message\"&gt;&lt;/p&gt; &lt;button id=\"btn\"&gt;获取数据&lt;/button&gt; &lt;script&gt; $(function () &#123; $('#btn').click(function () &#123; $.ajax(&#123; 'url': '/home/senddata', 'type': 'post', success: function (data) &#123; $('#message').html('用户名：' + data.UserName + \"&lt;br/&gt;年龄：\" + data.Age); &#125;, error: function (message) &#123; alert('error:' + message.statusText); &#125; &#125;); &#125;); &#125;); &lt;/script&gt; 匿名类型 使用Newtonsoft将匿名类型转换为json格式即可解决该问题。使用NuGet引入Newtonsoft.Json包 1234567891011121314151617181920public ActionResult Index()&#123; string json = JsonConvert.SerializeObject(new &#123; UserName = \"雪飞鸿\", Age = 24 &#125;); //也可以直接序列化JSON格式的字符串 //dynamic jsonObj = JsonConvert.DeserializeObject(\"&#123; UserName : \\\"雪飞鸿\\\", Age : 24 &#125;\"); dynamic jsonObj = JsonConvert.DeserializeObject(json); return View(jsonObj);&#125;// view&lt;html&gt;&lt;head&gt; &lt;meta name=\"viewport\" content=\"width=device-width\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;用户名：@Model.UserName&lt;/p&gt; &lt;p&gt;年龄：@Model.Age&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; cookie 123456789101112131415public ActionResult Index()&#123; Response.SetCookie(new HttpCookie(\"key\", \"cookie\")); return View();&#125;&lt;body&gt; &lt;p id=\"message\"&gt;&lt;/p&gt; &lt;script&gt; $(function () &#123; var message = $.cookie('key'); $('#message').text(message); &#125;) &lt;/script&gt;&lt;/body&gt;","categories":[],"tags":[{"name":"Asp.net Mvc","slug":"Asp-net-Mvc","permalink":"http://yoursite.com/tags/Asp-net-Mvc/"}]},{"title":"linux 下配置 ss","slug":"2017083108","date":"2017-08-31T09:23:11.000Z","updated":"2017-11-11T04:19:42.000Z","comments":true,"path":"2017/08/31/2017083108/","link":"","permalink":"http://yoursite.com/2017/08/31/2017083108/","excerpt":"","text":"linux 下配置 ss1. gui 方式安装shadow-qt5 linux ss github地址 在这里 添加PPA源：sudo add-apt-repository ppa:hzwhuang/ss-qt5 更新软件列表：sudo apt-get update 安装shadowsocks：sudo apt-get install shadowsocks-qt5 2. 命令方式 安装python-pip：apt-get install python-pip 安装shadowsocks：pip install shadowsocks 启动客户端sslocal -s server_ip -p server_port -l 1080 -k password -t 600 -m aes-256-cfb -k 密码要加”双引号” 3.chrome 代理设置 安装switchOmage 代理插件 安装好插件后新建情景模式比如命名为SS，其他默认之后创建，之后在代理协议选择SOCKS5，地址为127.0.0.1,端口默认1080（保证此处端口号和上面设置的一致） 。然后保存即应用选项。 接着点击自动切换（auto switch），上面的不用管，在按照规则列表匹配请求后面选择刚才新建的SS，默认情景模式选择直接连接。点击应用选项保存。 再往下规则列表设置选择AutoProxy 然后将这个地址填进去，并将此处的url设置为规则列表网址，点击立即更新情景模式 全局翻墙 安装配置proxychains 全局翻墙通过proxychains实现，即将任何程序和ss的proxy建立链接，原理和浏览器的代理相似。 下载 sudo apt-get install proxychains 配置 sudo nano /etc/proxychains.conf //nano比vim对新手更友好 在最后的ProxyList里加入Shawdowsocks的代理设置： socks5 127.0.0.1 1080 使用，打开ss-qt5的前提下，在需要翻墙的命令前打上proxychains即可。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"MongoDB 操作","slug":"2017083107","date":"2017-08-31T09:22:49.000Z","updated":"2017-11-11T04:18:46.000Z","comments":true,"path":"2017/08/31/2017083107/","link":"","permalink":"http://yoursite.com/2017/08/31/2017083107/","excerpt":"","text":"MongoDB 操作1.MongoDB 概述MongoDB 是一款跨平台, 面向文档的数据库。特点：高性能，高可用性，可扩展。两个主要概念：集合和文档 一个 MongoDB 服务器有多个数据库，数据库是集合的实际容器，每个数据库都在文件系统有自己的一组文件 集合是一组 MongoDB 文档。相当于关系型数据库 (RDBMS) 中表的概念。集合位于单独的一个数据库中。集合中的多个文档可以有多个不同的字段。 文档是一组键值对。文档有动态的模式，文档不需要同样的字段和结构。 相当于关系型数据库中的行。字段相当于列。 MongoDB 适用领域：大数据，内容管理及交付，移动和社会化基础设施，用户数据管理，数据中心 2.MongoDB 安装 3.MongoDB 主要操作3.1 创建数据库use + 数据库名称 创建数据库，use 命令创建一个新的数据库，如果数据库存在，则返回该数据库 use DATABASE_NAME 123use mydb # 创建数据库或返回数据库db # 检查查看当前数据库show dbs # 检查数据库列表（空表没有数据），mongodb 默认数据库时test db.dropDatabase() 删除选定数据库，没有选定会将默认的test 数据库删除 12use mydb # 删除数据库前要先返回该数据库db.dropDatabase() 3.2 创建集合db.createCollection( name, options) name 为所要创建的集合名称，options 可选，指定集合配置的文档。 12345678910use testdb.createCollection(\"myCollection\")show collletioS # 查看创建集合---------db.createCollection(\"mycol\",&#123;capped:true,autoIndexID:true,size:879,max:1000&#125;)# 集合配置参数意义 max 固定集合中包含文档的最大数量 size 为固定集合指定最大值# capped 创建固定集合，达到最大值覆盖 autoIndexID 自动在 _id 字段创建索引---------db.newCollectionName.insert(&#123;\"name\":\"jack\"&#125;) # 插入文档时，集合自动创建db.collectionname.drop() # 删除集合，成功删除返回true 3.3 MongoDB 数据类型 数据类型 类型 数据类型 类型 数据类型 类型 String 字符串(utf8) Integer 整型数值(32)(64) Boolean 布尔值(真假) Double 双精度浮点型 Min/Max keys 对比元素最小最高值 Arrays 数组列表存储为一个键 Timestamp 记录文档修改时间 Objext 用于内嵌文档那个 Null 创建空值 Date 日期时间 ObjextID 创建文档ID Code 在文档中存储js代码 3.3 MongDB 增删改查插入( 增加)db.collection_name.insert(document) db.collection_name.copy(document)文档id(ObjextID) 每个文档都一个唯一ID 如果没有指定ID mongodb 会自动为文档创建一个唯一的ID ，save 方法会覆盖指定id的全部数据 查询db.collection_name.find() # 非结构化方式显示所有文档那个 findOne() 只返回一个文档 db.collection_name.find().pretty() # 以结构化方式显示结构 12345678910条件查询『字段：条件』 条件：&#123; 判断 : value &#125;db.mycol.find(&#123;\"by\":123&#125;).pretty() # ： 字段 等于；类似 where by = 123db.mycol.find(&#123;\"likes\":&#123;$lt:123&#125;&#125;).pretty() # $lt 小于 ；类似 where likes &lt; 123db.mycol.find(&#123;\"likes\":&#123;$lte:123&#125;&#125;).pretty() # $lte 小于或等于 ；类似 where likes &lt;= 123db.mycol.find(&#123;\"likes\":&#123;$gt:123&#125;&#125;).pretty() # $gt 大于 ； 类似 where &gt; 123;db.mycol.find(&#123;\"likes\":&#123;$gte:123&#125;&#125;).pretty() # $gte 大于或等于；类似 where &gt;= 123;db.mycol.find(&#123;\"likes\":&#123;$ne:123&#125;&#125;).pretty() # $ne 不等于 ；类似 where ！= 123db.mycol.find(&#123;key1:value1,key2:value2&#125;).pretty() # and 语句 where key1=value1 and key2=value2db.mycol.find($or[key1:value1,key2:value2]) # or 语句db.mycol.find(&#123;key1:value1,$or:[&#123;&#125;&#123;&#125;]&#125;) # and or 结合 更新(改)update() 更新已有文档中的值 1234db.mycol.update(&#123;\"title\":\"jacke\"&#125;,&#123;$set:&#123;\"title\":\"newjacke\"&#125;&#125;) #db.mycol.update(&#123;\"title\":\"jacke\"&#125;,&#123;$set:&#123;\"title\":\"newjacke\"&#125;,&#123;multi:true&#125;) # 更新多个文档db.mycol.save(&#123;\"_id\":value,\"key1\":newValue&#125;) # 替换原有文档，覆盖全部数据 删除remove() 方法 清除集合中的文档 12345db.collection_name.remove(DELLETION_CRITTERIA,justOne)# justOne:设置只删除一个文档 true or 1db.mycol.remove(&#123;\"key\":\"value\"&#125;)# 将集合中符合标准所有文档删除 映射MongoDB 映射： 指的是只选择文档中的必要数据 db.COLLECTION_NAME.find({},{key:1}) # key=字段 1，显示；0，隐藏字段;在查询语句后面添加 限制记录db.mycol.find({},{}).limit(2) # 限制查询显示文档个数 db.mycol.find({},{}).limit(1).skip(1) # skip 跳过的数量条数 db.mycol.find({},{}).sort(&quot;key&quot;:-1) # sort 1表示升序，-1表示降序 4.索引索引是一种特殊的数据结构，能够实现高效查询。 db.COLLECTION_NAME.ensureIndex({KEY:1}) # 1 代表升序；-1 代表降序 backgroud:true,false 在后台建立索引 聚合能够处理数据记录并返回结果 123db.COLLECTION_NAME.aggregate(aggregate_operation) # 聚合操作= count(*) group bydb.mycol.aggregate([$group:&#123;_id:\"$by_user\",num_tutorial:&#123;$sum:1&#125;&#125;])==&gt; select by_user,count(*) from mycol group by by_user 表达式 描述 表达式 描述 表达式 描述 表达式 描述 $sum 计算总和 $min 最小值 $last 根据排序获取最后一个 $push 在结果文档中插入值到一个数组 $avg 计算平均值 $max 最大值 $first 第一个 $addToSet 在结果文档中插入值到一个数组，不创建副本","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"python 学习笔记二","slug":"2017083106-1","date":"2017-08-31T09:16:23.000Z","updated":"2017-08-31T01:22:04.000Z","comments":true,"path":"2017/08/31/2017083106-1/","link":"","permalink":"http://yoursite.com/2017/08/31/2017083106-1/","excerpt":"","text":"python 学习笔记二函数1234567891011121314151617&gt;&gt;&gt; def test(a , b=-99): # 函数定义方法 函数参数可以设置默认值，赋参不完全时 使用默认参数··· global a # 函数内定义全局变量... if a &gt; b:... return True... else:... return False&gt;&gt;&gt; func(12, 24)··· a is 12 and b is 24 and c is 10··· \"\"\" Function to find the length of the longest side of a right triangle. :arg a: Side a of the triangle :arg b: Side b of the triangle :return: Length of the longest side c as float \"\"\" # 文档字符串 说明如何使用字符串 map 函数12345678&gt;&gt;&gt; lst = [1, 2, 3, 4, 5]&gt;&gt;&gt; def square(num):... \"返回所给数字的平方.\"... return num * num... # 接受一个函数和一个序列（迭代器）作为输入，··· # 然后对序列（迭代器）的每一个值应用这个函数，返回一个序列（迭代器），其包含应用函数后的结果&gt;&gt;&gt; print(list(map(square, lst)))[1, 4, 9, 16, 25] 文件操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import os # 包导入import sysdef parse_file(path): \"\"\" 分析给定文本文件，返回其空格、制表符、行的相关信息 :arg path: 要分析的文本文件的路径 :return: 包含空格数、制表符数、行数的元组 \"\"\" fd = open(path) # 文件打开 # 可以接受两个参数 ，文件路径和读写模式 默认只读 i = 0 # \"r\"，以只读模式打开，只能读取文件但不能编辑/删除文件 spaces = 0 # \"w\"，以写入模式打开，可以进行删除 tabs = 0 # \"a\"，追加模式，写入到文件中何数据添加到末尾 for i,line in enumerate(fd): # fd.read() 读取整个文件 spaces += line.count(' ') # fd.readline() 每次读取文件的一行 tabs += line.count('\\t') # fd.readlines() 读取所有行到一个列表中 # 现在关闭打开的文件 # fd.write() 向文件中写入数据 fd.close() # 文件关闭 enumerate(fd) 可以同时得到索引位置 和对应值 # with open('sample.txt') as fobj 使用with操作文件不用手动关闭 # 以元组形式返回结果 return spaces, tabs, i + 1def main(path): \"\"\" 函数用于打印文件分析结果 :arg path: 要分析的文本文件的路径 :return: 若文件存在则为 True，否则 False \"\"\" if os.path.exists(path): spaces, tabs, lines = parse_file(path) print(\"Spaces &#123;&#125;. tabs &#123;&#125;. lines &#123;&#125;\".format(spaces, tabs, lines)) return True else: return Falseif __name__ == '__main__': if len(sys.argv) &gt; 1: main(sys.argv[1]) else: sys.exit(-1) sys.exit(0) python 异常处理常见错误 SyntaxError 在 python3 中使用 python2 行首多打了一个空格就会产生 IndentationError 访问一个未定义的变量则会发生 NameError TypeError 也是一种经常出现的异常。当操作或函数应用于不适当类型的对象时引发 处理错误使用 try…except 块来处理任意异常。 12345678910try: statements to be inside try clause statement2 statement3 raise ValueError(\"A value error happened.\") # 抛出异常 ...except ExceptionName: statements to evaluated in case of ExceptionName happensfinally: print(\"dsa\") 类1234567891011class nameoftheclass(parent_class): # class 创建类 statement1 statement2 statement3def __init__(self, realpart, imagpart): # 类实例化操作自动调用 __init__() 该函数可以有参数 # self 类的实例，定义类的方法中必须有 self.r = realpart self.i = imagpardef f(self): return 'hello world'emp1 = nameoftheclass(\"Zara\", 2000) # 直接使用类的名称来进行实例化 从_init_ 函数接受参数 类中属性的修改 类的属性 __private_attrs：两个下划线开头，声明该属性为私有 单下划线、双下划线、头尾双下划线说明： foo : 定义的是特列方法，类似 init() 之类的。 _foo : 单下划线开头的表示 protected 类型的变量,不能用于from module import * __foo : 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行访问了。 形式 功能 内置类 内置类属性 hasattr(class,attr) 类中有属性返回true _dict_ 类的属性（包含一个字典，由类的数据属性组成） getattr(class,attr) 返回类属性值 _doc_ ; _bases_ 类的文档字符串;类的所有父类组成的元组 setattr(class,attr) 添加(设置)属性值 _name_ 类名 delattr(class,attr) 删除属性 _moudle_ 类定义所在的模块 继承python中继承中的一些特点： 1：在继承中基类的构造（_init_()方法）不会被自动调用，它需要在其派生类的构造中亲自专门调用。 2：在调用基类的方法时，需要加上基类的类名前缀，且需要带上self参数变量。区别于在类中调用普通函数时并不需要带上self参数 3：Python总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。 1234567891011121314151617181920212223242526272829#!/usr/bin/python# -*- coding: UTF-8 -*-class Parent: # 定义父类 parentAttr = 100 def __init__(self): print \"调用父类构造函数\" def parentMethod(self): print '调用父类方法' def setAttr(self, attr): Parent.parentAttr = attr def getAttr(self): print \"父类属性 :\", Parent.parentAttrclass Child(Parent): # 定义子类 继承支持多继承 def __init__(self): print \"调用子类构造方法\" def childMethod(self): print '调用子类方法 child method'c = Child() # 实例化子类c.childMethod() # 调用子类的方法c.parentMethod() # 调用父类方法c.setAttr(200) # 再次调用父类的方法c.getAttr() # 再次调用父类的方法 python 代码规则 与括号，冒号，分号，逗号保持紧凑 切片内冒号两侧必须有相同的空格数量 import 语句 放在文件顶部，在模块注释和文档字符串之下，顺序为标准库，第三方库，当前库 在赋值操作符，比较操作符，和布尔运算符两侧加入空格 包名应该写短，全部小写，不推荐使用下划线 常量全部大写，单词之间以下划线分隔 生成器的值不能重复使用","categories":[],"tags":[{"name":"后台","slug":"后台","permalink":"http://yoursite.com/tags/后台/"}]},{"title":"mgo 驱动使用指南","slug":"2017083106","date":"2017-08-31T09:16:04.000Z","updated":"2017-11-11T04:18:06.000Z","comments":true,"path":"2017/08/31/2017083106/","link":"","permalink":"http://yoursite.com/2017/08/31/2017083106/","excerpt":"","text":"mgo 驱动使用指南 mgo 是 MongoDB 的 go 语言驱动，golang 网站的数据存储就是用的 MongoDB + mgo 操作123456789101112131415161718go get gopkg.in/mgo.v2 # 安装----import( # 1.导入 mgo 包\"gopkg.in/mgo.v2\"\"gopkg.in/mgo.v2/bson\")----func Dial(url string)(*Session error) # Dial 方法 mgo包自带与 Mongo 服务器建立连接session, err := mgo.Dial(\"url\") # 2.连接服务器# 具体使用 本机地址 127.0.0.1：27017 or localhost# 远端地址 mongo://url----func (s *Session) DB(name string) *Database # DB 方法定义db := session DB(\"test\") # 3.切换数据库----func (db *Database) C(name string) *Collection # C 方法定义c:=db.C(\"users\") # 4.切换集合---- 对集合进行操作12345678910111213141516171819202122# 和集合对应的 struct 的编写type User struct&#123; Id_ bson.ObjectID 'bson:\"_id' # 字段首字母大写，不然不可见，id可以不定义，可以自动生成 Name string 'bson:\"name\"' # bson:\"name\" 定义MongoDB集合中的字段名 Age int 'bson:\"age\"' JonedAt time.Time 'bson:\"joined_at\"' Interests []string 'bson:\"interests\"'&#125;# mgo 中的增删改查----func (c *Collection)Insert(docs ...interface&#123;&#125;) error # Insert 方法定义err = c.Insert(&amp;User&#123;Id_: bson.NewObjectID(), # Insert 方法返回一个错误 Name:\"jimmy\", # 错误为空保证插入正确 Age: 33, JoinedAt: time.Now(), Interests: []string&#123;\"Develop\",\"movie\"&#125;,&#125;)if err!= nil &#123; panic(err)&#125; 通过func (c *Collection) Find(query interface{}) *Query来进行查询，返回的Query struct可以有附加各种条件来进行过滤。 通过Query.All()可以获得所有结果，通过Query.One()可以获得一个结果，注意如果没有数据或者数量超过一个，One()会报错。 条件用bson.M{key: value}，注意key必须用MongoDB中的字段名，而不是struct的字段名。 123456789101112# 无条件查询var users []Userc.Find(nil).All(&amp;users)fmt.Println(users)id := \"5204af979955496907000001\"objectId := bson.ObjectIdHex(id)user := new(User)c.Find(bson.M&#123;\"_id\": objectId&#125;).One(&amp;user)fmt.Println(user)c.FindId(objectId).One(&amp;user) # 单条件查询 =($eq) c.Find(bson.M{&quot;name&quot;: &quot;Jimmy Kuu&quot;}).All(&amp;users) !=($ne) c.Find(bson.M{&quot;name&quot;: bson.M{&quot;$ne&quot;: &quot;Jimmy Kuu&quot;}}).All(&amp;users) &gt;($gt) c.Find(bson.M{&quot;age&quot;: bson.M{&quot;$gt&quot;: 32}}).All(&amp;users) &lt;($lt) c.Find(bson.M{&quot;age&quot;: bson.M{&quot;$lt&quot;: 32}}).All(&amp;users) &gt;=($gte) c.Find(bson.M{&quot;age&quot;: bson.M{&quot;$gte&quot;: 33}}).All(&amp;users) &lt;=($lte) c.Find(bson.M{&quot;age&quot;: bson.M{&quot;$lte&quot;: 31}}).All(&amp;users) in($in) c.Find(bson.M{&quot;name&quot;: bson.M{&quot;$in&quot;: []string{&quot;Jimmy Kuu&quot;, &quot;Tracy Yu&quot;}}}).All(&amp;users) # 多条件查询 and($and) c.Find(bson.M{&quot;name&quot;: &quot;Jimmy Kuu&quot;, &quot;age&quot;: 33}).All(&amp;users) or($or) c.Find(bson.M{&quot;$or&quot;: []bson.M{bson.M{&quot;name&quot;: &quot;Jimmy Kuu&quot;}, bson.M{&quot;age&quot;: 31}}}).All(&amp;users) # 修改字段的值($set) c.Update(bson.M{&quot;_id&quot;: bson.ObjectIdHex(&quot;5204af979955496907000001&quot;)}, bson.M{&quot;$set&quot;: bson.M{ &quot;name&quot;: &quot;Jimmy Gu&quot;, &quot;age&quot;: 34, }}) inc($inc) # 字段增加值 c.Update(bson.M{&quot;_id&quot;: bson.ObjectIdHex(&quot;5204af979955496907000001&quot;)}, bson.M{&quot;$inc&quot;: bson.M{ &quot;age&quot;: -1, }}) push($push) # 从数组中增加一个元素 c.Update(bson.M{&quot;_id&quot;: bson.ObjectIdHex(&quot;5204af979955496907000001&quot;)}, bson.M{&quot;$push&quot;: bson.M{ &quot;interests&quot;: &quot;Golang&quot;, }}) pull($pull) # 从数组中删除一个元素 c.Update(bson.M{&quot;_id&quot;: bson.ObjectIdHex(&quot;5204af979955496907000001&quot;)}, bson.M{&quot;$pull&quot;: bson.M{ &quot;interests&quot;: &quot;Golang&quot;, }}) # 删除 c.Remove(bson.M{&quot;name&quot;: &quot;Jimmy Kuu&quot;})","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"python 学习笔记一","slug":"2017083105","date":"2017-08-31T09:11:53.000Z","updated":"2017-11-11T04:17:12.000Z","comments":true,"path":"2017/08/31/2017083105/","link":"","permalink":"http://yoursite.com/2017/08/31/2017083105/","excerpt":"","text":"python 学习笔记 一 phython 参考文档Python tutorial：http://www.pythondoc.com/pythontutorial3/index.htmlPython for you and me：http://pymbook.readthedocs.io/en/latest/The Python Standard Library：https://docs.python.org/3/library/index.html 代码风格 使用 4 个空格来缩进 永远不要混用空格和制表符 在函数之间空一行 在类之间空两行 字典，列表，元组以及参数列表中，在 , 后添加一个空格。对于字典，: 后面也添加一个空格 在赋值运算符和比较运算符周围要有空格（参数列表中除外），但是括号里侧不加空格：a = f(1, 2) + g(3, 4) Python 的注释以 # 字符开始的，在 # 字符到行尾之间的所有东西都被程序忽略为注释，也就说对程序没有任何影响。（ # 后跟一个空格，然后再写注释。） input（“接受键盘输入函数”） 文件中第一行的前两个字符 #! 称为 Shebang ，目的是告诉 shell 使用 Python 解释器执行其下面的代码。 ./filename.py 执行方法 为文件添加可执行权限 1chmod +x filename python 中不需要为变量指定数据类型，直接给变量赋值即可。 导入模块 1import math 变量和数据类型python 关键字123456789False def if raiseNone del import returnTrue elif in tryand else is whileas except lambda withassert finally nonlocal yieldbreak for not class from or continue global pass python 运算符 运算符 功能 逻辑运算符 功能 类型转换 转换路径 成员运算符 逻辑运算符 % 取余 and 与 float(string) 字符 -&gt; 浮点 in is / 除法 or 或 string(float) 浮点 -&gt; 字符 not in is not // 取整 not 非 type1(type2) type2 -&gt; type1 x**y 返回x的y次幂 * 两个数相乘;返回一个被重复若干次的字符串 python 输出函数1print(\"Year &#123;&#125; Rs. &#123;:.2f&#125;\".format(year, value)) 称为字符串格式化，大括号和其中的字符会被替换成传入 str.format() 的参数,即 year 和 value。 {:7.2f} 的意思是替换为 总长为7,2 位精度的浮点数;{:5d} 的意思是替换为 5个字符宽度的整数，宽度不足则使用空格填充。 控制循环if else第二行务必缩进 (四个空格) 123456if expression: do thiselif expression1: do thiselse: do this 真值检测12if x: do this 循环while循环 123while condition: statement1 statement2 for 循环python for 循环可以遍历任何序列中的每一个元素 123a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]for x in a[::2]: print(x) 遍历数值序列 1234for i in range(0,5): print(i)else: print(\"bye\") 循环后面的 else 语句会在循环结束后执行； continue 跳出本次循环 ；break 跳出整个循环；Python pass是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句。 序列(数组)列表列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现。列表的数据项不需要具有相同的类型创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。 列表常用方法 方法 代码 方法 代码 添加元素到表尾 list.append(x) 指定位置插入元素 list.insert(i,x) 表1添加到表2 list.extend(L) 删除值为x元素 list.remove(x) 删除位置元素返回 list.pop([ i ]) 删除表中所有元素 list.clear() 返回值为x的索引 list.index(x) 返回x在列表中出现次数 list.sort() 倒排列表 list.reverse() 返回列表拷贝 list.copy() python列表函数 功能 python列表函数 功能 max(list) 列表最大值 list(seq) 元组转换为列表 min(list) 列表最小值 len(list) 列表元素长度 列表常用操作 列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表。 切片 a [ : ] 切片索引默认第一个为 0 ; 第二个为字符串的长度。 切片索引为负号时则从列表末尾开始计数 ( 从 0 开始，-1，-2)，切片长度为索引之差。 Python 能够优雅地处理那些没有意义的切片索引：一个过大的索引值(即大于列表实际长度)将被列表实际长度所代替，当上边界比下边界大时(即切片左值大于右值)就返回空列表。 切片操作可以设置步长，a[1::2] 从切片索引 1 到列表末尾，每隔两个元素取值。 列表可以修改元素。 对切片进行赋值操作也会影响原列表。 遍历列表（或任何序列类型）的同时获得元素索引值，你可以使用 enumerate() 123456&gt;&gt;&gt; for i, j in enumerate(['a', 'b', 'c']):... print(i, j)...0 a1 b2 c 同时遍历两个 123456&gt;&gt;&gt; a = ['Pradeepto', 'Kushal']&gt;&gt;&gt; b = ['OpenSUSE', 'Fedora']&gt;&gt;&gt; for x, y in zip(a, b):... print(\"&#123;&#125; uses &#123;&#125;\".format(x, y))Pradeepto uses OpenSUSEKushal uses Fedora 列表推导式 a=[x**2 for x in range(10)] 创建列表不产生副作用。 列表推导式由包含一个表达式的中括号组成，表达式后面跟随一个 for 子句，之后可以有零或多个 for 或 if 子句。结果是一个列表，由表达式依据其后面的 for 和 if 子句上下文计算而来的结果构成。列表推导式可以嵌套。 元组Python的元组与列表类似，不同之处在于元组的元素不能修改。元组使用小括号，列表使用方括号。元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。 元组与列表的区别，元组它的关键是不可变性。如果在程序中以列表的形式传递一个对象的集合，它可能在任何地方改变；如果使用元组的话，则不能。元组提供了一种完整的约束。 1tup1 = (a,) 元组常用操作 元组中只包含一个元素时，需要在元素后面添加逗号 元组与字符串类似，下标索引从0开始，可以进行截取，组合等 元组中的元素值是不允许修改的，但我们可以对元组进行连接组合 元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组 元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素 任意无符号的对象，以逗号隔开，默认为元组 tuple(seq)将列表转换为元组。 字典字典是另一种可变容器模型，且可存储任意类型对象。 字典的每个键值(key=&gt;value)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号({})中 字典常用操作 键必须是唯一的，但值则不必。值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。 使用 in 关键字查询指定的键是否存在于字典中。&quot;a&quot; in data 如果你想要遍历一个字典，使用字典的 items() 方法 for x, y in data.items(): dict() 可以从包含键值对的元组中创建字典 dict(((&#39;Indian&#39;,&#39;Delhi&#39;),(&#39;Bangladesh&#39;,&#39;Dhaka&#39;))) 往字典中添加元素dict.setdefault(key, default) ：data.setdefault(&#39;names&#39;, []).append(&#39;Ruby&#39;) 字典删除操作 123del dict['Name']; # 删除键是'Name'的条目dict.clear(); # 清空词典所有条目del dict ; # 删除词典 不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住。键不可用列表。 集合 集合是一个无序不重复元素的集 大括号或 set() 函数可以用来创建集合 想要创建空集合，你必须使用 set() 而不是 {}。后者用于创建空字典 1basket = &#123;'apple', 'orange', 'apple', 'pear', 'orange', 'banana'&#125; 字符串单引号（’…’）或双引号（”…”） 引入字符串 无格式 不支持自动换行 需要在字符串内手动加入换行符 \\n “””…””” 或 ‘’’…’’’ 可自动将换行符加入字符串内 字符串方法 方法 功能 方法 功能 title() 字符串单词首字母大写 upper()/lower() 字符串全部大小写 isalnum() 字符串是否全部为字母数字 isalpha() 是否全部为字母 spilt() 分割字符串，参数为分割符 join() 使用指定字符连接字符串 strip() 字符串剥离 find() 查找字符串索引，没有返回-1","categories":[],"tags":[{"name":"后台","slug":"后台","permalink":"http://yoursite.com/tags/后台/"}]},{"title":"go 语言学习笔记","slug":"2017083104","date":"2017-08-31T08:55:59.000Z","updated":"2017-11-11T04:16:16.000Z","comments":true,"path":"2017/08/31/2017083104/","link":"","permalink":"http://yoursite.com/2017/08/31/2017083104/","excerpt":"","text":"go 语言学习笔记Go 概述 Go 语言使用 C++ 风格的注释：//表示单行注释，到行尾结束，/*...*/表示多行注释。所有的Go语言代码只能放置于一个包中，每一个 Go 程序都必须包含一个 main 包以及一个 main() 函数，main() 函数作为整个程序的入口。 我们的第一个 Go 程序源代码中，第一行 package main 表明当前源文件属于 main 包，import 后面是导入的包，只有需要用到的包才需要导入，导入的包没有使用，则会导致编译失败。 Go 语言语句是使用分号进行分隔的，但是在一般情况下我们不用手动添加，编译器会自动完成这些工作，除非需要在一行中写多条语句。 Go 语言的函数和方法都以关键字 func 进行定义。以上代码中的 main 函数的第一行使用了 := 操作符，该符号声明并初始化了一个字符串变量。 Go 语言虽然是一门静态强类型的语言，但是在使用:=操作符时，Go语言会根据符号右边的值推导出符号左边变量的类型。这儿的例子中，’World’是一个字符串，所以Go语言将变量 target 创建为一个字符串类型，并且进行赋值 go run hello.go 命令直接让Go源文件运行，不会生成任何可执行文件，这可以快速查看源代码的执行效果。一般情况下，我们将Go源代码编译链接成可执行文件，以方便随时运行。可以使用以下命令进行。 go build hello.go 编译和链接hello.go代码，并且生成了可执行文件hello。./hello，执行hello. goroutine是Go语言并行设计的核心。goroutine是一种比线程更轻量的实现，十几个goroutine可能在底层就是几个线程。要使用goroutine只需要简单的在需要执行的函数前添加go关键字即可。 channel就像一个管道，但是可以双向传输数据，通过它我们可以接收和发送数据，值得注意的地方是channel只能通过Go语言内建的函数make(chan type)创建，其中type指明了该channel能传递的数据类型。 常用go命令go build 主要用于测试编译。在包的编译过程中，若有必要，会同时编译与之相关联的包。 go run 编译并运行Go语言源代码，这对于我们快速运行测试代码非常方便。 go test执行这个命令，会自动读取源码目录下面名为*_test.go的文件，生成并运行测试用的可执行文件。 go 工具集中提供了一个go fmt命令 它可以帮你格式化你写好的代码文件，使你写代码的时候不需要关心格式，你只需要在写完之后执行go fmt &lt;文件名&gt;.go，你的代码就被修改成了标准格式。 go install 这个命令在内部实际上分成了两步操作：第一步是生成结果文件(可执行文件或者.a包)，第二步会把编译好的结果移到\\$GOPATH/pkg或者\\$GOPATH/bin 基础关键字 关键字 关键字 关键字 关键字 关键字 break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 类型 类型 类型 类型 类型 类型 类型 类型 bool byte complex64 complex128 error float32 float64 int int8 int16 int32 int64 rune string uint uint8 uint16 uint32 uint64 uintptr 常量true false iota 零值Nil 函数 函数 函数 函数 函数 append cap close complex copy delete imag len make new panic print println real recover 声明常量使用关键字 const 声明，变量可以使用关键字 var 声明，也可以通过使用快捷变量声明语法 := 。Go语言可以自动推断出所声明变量的类型。对于没有显式初始化的变量，Go 语言总是将零值赋值给该变量。当需要设置多个常量的时候，不必重复使用 const 关键字，可以使用以下语法 12345const ( Cyan = 0 Black = 1 White = 2) 字符串Go语言中字符串的可以使用双引号( “ )或者反引号( ` )来创建。双引号用来创建可解析的字符串字面量，所谓可解析的是指字符串中的一些符号可以被格式化为其他内容，如”\\n”在在输出时候会被格式化成换行符， 如果需要按照原始字符输出必须进行转义。而反引号创建的字符串原始是什么样，那输出还是什么，不需要进行任何转义。 常用转义字符 转义字符 含义 \\\\ 表示反斜线 \\‘ 单引号 \\“ 双引号 \\n 换行符 \\uhhhh 4个16进制数字给定的Unicode字符 数组切片12345# 先定义数组Var myArray [10]int = [10]&#123;1,2,3,4,5&#125;Var mySlice []int = myArray[:5]5个元素Var mySlice []int = myArray[:]所有元素Var mySlice []int = myArray[5:]5个以后的 异常异常 defer panic recover Defer 简单处理 defer srcFile.Close() 复杂处理 defer func(){}() 先进后出原则。 异常处理机制：panic类似于其他程序中的异常，而recover 则用于恢复异常。当panic()函数被调用时，外围函数或者方法的执行会立即终止。然后任何延迟执行的函数都会被调用。这个过程一直在调用栈中层层发生，最后到达main函数，这个时候整个程序会终止，最终将最初的调用栈信息输出到stderr。但是当延迟执行函数中包含recover语句时，recover会捕捉到panic引发的异常，并停止panic的传播，这个时候我们能够以任何我们想用的方式处理p 杂项golang 函数以及函数和方法的区别 官方的解释是，方法是包含了接收者的函数。 “_”(下划线)，可以简单理解为赋值但以后不再使用，在golang中使用比较多，使用场合不单一 Range遍历的用法 For i,v:= range mySlice{} ...type不定参数类型 可以接入不定数量的参数 Interface{} 表示任意类型的数据 Go 语言中同时有函数和方法。方法就是一个包含了接受者（receiver）的函数，receiver可以是内置类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集。 func (r ReceiverType) funcName(parameters) (results) go语言的结构体 和其他语言的类有同等的地方。Go语言的结构体只是很普通的复合类型。 初始化 Rect 构造函数 goroutine直接理解成为线程就可以了。当对一个函数调用go，启动一个goroutine的时候，就相当于起来一个线程，执行这个函数。 1 channel只能使用make来进行创建 基本格式是 c := make(chan int) int是说明这个管道能传输什么类型的数据 2 往channel中插入数据的操作 c &lt;- 1 是不是很形象 3 从channel中输出数据 &lt;- cchannel分为两种：一种是有buffer的，一种是没有buffer的，默认是没有buffer的 12345ci := make(chan int) //无buffercj := make(chan int, 0) //无buffercs := make(chan int, 100) //有buffer 有缓冲的channel，因此要注意“放”先于“取” 无缓冲的channel，因此要注意“取”先于“放” 匿名函数 12345go f(\"goroutine\")go func(msg string) &#123; fmt.Println(msg)&#125;(\"going\") goroutine使用以下的go语句进行创建: 123go function(arguments)go func(parameters) &#123; block &#125; (arguments)goroutine之间需要相互协作，最好的方式是通过channel来交换数据。 在Go中函数也是一种变量，我们可以通过type来定义它 cookie 是存储于访问者的计算机中的变量。每当同一台计算机通过浏览器请求某个页面时，就会发送这个 cookie。你可以使用 JavaScript 来创建和取回 cookie 的值。 12Mutex.Lock()(sync.mutex)同步锁（只允许一个线程运行）Mutex.Runlock()(sync.rwmutex)（单写多读模型） Json 处理 12解析JSON json.Unmarshal([]byte(str), &amp;s)生成json b, err := json.Marshal(s)","categories":[],"tags":[{"name":"后台","slug":"后台","permalink":"http://yoursite.com/tags/后台/"}]},{"title":"Ajax 学习","slug":"2017083103","date":"2017-08-31T08:45:40.000Z","updated":"2017-11-11T04:13:46.000Z","comments":true,"path":"2017/08/31/2017083103/","link":"","permalink":"http://yoursite.com/2017/08/31/2017083103/","excerpt":"","text":"Ajax 学习 AJAX = 异步 JavaScript 和 XML。 AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 AJAX是基于现有的Internet标准AJAX是基于现有的Internet标准，并且联合使用它们： XMLHttpRequest 对象 (异步的与服务器交换数据) JavaScript/DOM (信息显示/交互) CSS (给数据定义样式) XML (作为转换数据的格式) AJAX应用程序与浏览器和平台无关的！ Ajax 操作步骤 触发一个客户端事件。 创建一个 XMLHttpRequest 对象。 12345678var xmlhttp;if (window.XMLHttpRequest)&#123; // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xmlhttp=new XMLHttpRequest();&#125;else&#123; // IE6, IE5 浏览器执行代码 xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");&#125; 配置 XMLHttpRequest 对象。 使用 XMLHttpRequest 对象创建一个到 Web 服务器的异步请求。如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法： 1234567891011121314151617181920212223242526272829303132333435xmlhttp.open(\"GET\",\"ajax_info.txt\",true);# method:请求类型 url：文件在服务器上的位置 async：true(异步) false(同步)# method: post 请求与 get 请求的区别： 与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。 在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。 xmlhttp.send();# url: open() 方法的 url 参数是服务器上文件的地址 该文件可以是任何类型的文件（在传回响应之前，能够在服务器上执行任务）xmlhttp.send();# 请求发送到服务器 send(string): 仅用于 post 请求# responseText 获得字符串形式的响应数据# responseXML 获得 XML 形式的响应数据xmlhttp.onreadystatechange=function() &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText; &#125; &#125;# onreadystatechange 存储函数# readystate 从 0 到 4 发生变化 0 请求未初始化 1 服务连接已经建立 2 请求已接受 3 请求处理中 4 请求已经完成# status 200:\"ok\" 404:\"未找到页面\" Web 服务器返回包含 XML 文档的结果。 XMLHttpRequest 对象调用 callback() 函数处理结果。 更新 HTML DOM。 Jquery AjaxJquery Ajax 方法 序号 方法，描述 1 jQuery.ajax( options )使用一个 HTTP 请求加载一个远程页面。 2 jQuery.ajaxSetup( options )为 AJAX 请求设置全局设置。 3 jQuery.get( url, [data], [callback], [type] )使用一个 HTTP GET 请求加载一个远程页面。 4 jQuery.getJSON( url, [data], [callback] )使用一个 HTTP GET 请求加载 JSON 数据。 5 jQuery.getScript( url, [callback] )使用一个 HTTP GET 请求加载并执行一个 JavaScript 文件。 6 jQuery.post( url, [data], [callback], [type] )使用一个 HTTP POST 请求加载一个远程页面。 7 load( url, [data], [callback] )从远程文件加载 HTML 并把它注入到 DOM 中。 8 serialize( )将一组输入元素序列化一个字符串数据中。 9 serializeArray( ) 与.serialize()方法一样，序列化所有的表单及表单元素，但是返回 JSON 数据结构。 Jquery Ajax 事件1 ajaxComplete( callback )当一个 AJAX 请求完成后，附加一个要被执行的函数。 2 ajaxStart( callback )当一个 AJAX 开始并且没有准备好的操作时，附加一个要被执行的函数。 3 ajaxError( callback )当一个 AJAX 请求失败后，附加一个要被执行的函数。 4 ajaxSend( callback )在一个 AJAX 请求发送之前，附加一个要被执行的函数。 5 ajaxStop( callback )当全部的 AJAX 请求结束后，附加一个要被执行的函数。 6 ajaxSuccess( callback )当一个 AJAX 请求成功完成后，附加一个要被执行的函数。 Jquery Ajax 常用属性123456789$.ajax(&#123;url:需要请求的servlet地址;data:参数;type:post (get);dataType:表示服务器返回的数据类型;async:是否同步;cache:是否缓存;success:function();表示成功回调函数。&#125;) Jquery Ajax 上传文件先new一个FormData对象，然后向里面压入1个文件，然后用jQuery.ajax()方法上传这个FormData对象即可 1234567891011121314151617181920212223$('button').click(function() &#123; var formData = new FormData(); // formdata 一次可以传入多个数据，以键值对的形式传入 // 键名不一定是“file”，可以是任意名；写多行就可以压入多个文件，键名不可重名 formData.append('file',$('#myfile')[0].files[0]); // 当form表单是标准表单时： var formData = new FormData(); //这句可以改成var formData = new FormData(document.getElementById('form1')); //直接把form元素传给构造器就行了，剩下的事就不用管了，省去了所有的formData.append(...) $.ajax(&#123; url: '1.php', type: 'POST', data: formData, cache: false, // 要求jQuery不处理发送的数据，是为了不让jQuery把文件处理成字符串 processData: false, // 要求jQuery不设置Content-Type请求头，是为了不让jQuery用默认的请求头 contentType: false &#125;).then(function(data) &#123; console.log(data); &#125;);&#125;) 12345678910111213141516# 较为原始方法var file = document.getElementById(currentmodelID + \"_file\"); var filename = file.files[0].name; var formData = new FormData(); formData.append(filename, file.files[0]);var xhr = new XMLHttpRequest(); xhr.open(\"POST\", \"../handler/ImageHandler.ashx\", true); // 发送表单数据 xhr.send(formData); xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4) &#123; &#125; &#125;","categories":[],"tags":[{"name":"前台","slug":"前台","permalink":"http://yoursite.com/tags/前台/"}]},{"title":"css 布局","slug":"20170831-1","date":"2017-08-31T07:42:25.000Z","updated":"2017-11-11T04:10:04.000Z","comments":true,"path":"2017/08/31/20170831-1/","link":"","permalink":"http://yoursite.com/2017/08/31/20170831-1/","excerpt":"","text":"css 布局1.基本语法CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明: 选择器通常是您需要改变样式的 HTML 元素 每条声明由一个属性和一个值组成 属性（property）是您希望设置的样式属性（style attribute） 每个属性有一个值。属性和值被冒号分开 CSS声明总是以分号(;)结束，声明组以大括号({})括起来 为了让CSS可读性更强，你可以每行只描述一个属性: CSS注释以 &quot;/*&quot;开始, 以&quot;*/&quot;结束 CSS中，颜色值通常以以下方式定义: 十六进制 - 如：”#ff0000” (0xff0000 跟前面颜色一样 0x 代表透明度) RGB - 如：”rgb(255,0,0)” 颜色名称 - 如：”red” 2.选择器2.1 id 选择器HTML元素以id属性来设置id选择器,CSS 中 id 选择器以 “#” 来定义。 2.2 class 选择器class 选择器用于描述一组元素的样式 class 选择器有别于 id 选择器，class 可以在多个元素中使用。 class 选择器在 HTML 中以 class 属性表示, 在 CSS 中，类选择器以一个点”.”号显示： 所有拥有 class 为 center 的元素的属性 .center {text-align:center;} p 元素中 class 为 center 的属性p.center {text-align:center;} 3. css 创建3.1外部样式表当样式需要应用于很多页面时，外部样式表将是理想的选择。 123&lt;head&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\"&gt;&lt;/head&gt; 3.2 内部样式表当单个文档需要特殊的样式时，就应该使用内部样式表。你可以使用&lt;style&gt; 标签在文档头部定义内部样式表 1234567&lt;head&gt;&lt;style&gt;hr &#123;color:sienna;&#125;p &#123;margin-left:20px;&#125;body &#123;background-image:url(\"images/back40.gif\");&#125;&lt;/style&gt;&lt;/head&gt; 3.3 内联样式要使用内联样式，你需要在相关的标签内使用样式（style）属性。Style 属性可以包含任何 CSS 属性。本例展示如何改变段落的颜色和左外边距 &lt;p style=&quot;color:sienna;margin-left:20px&quot;&gt;这是一个段落。&lt;/p&gt; 3.4 多重样式优先级一般情况下，优先级如下：内联样式）Inline style &gt; （内部样式）Internal style sheet &gt;（外部样式）External style sheet &gt; 浏览器默认样式 4. css 样式4.1 背景 background-color 属性定义了元素的背景颜色. background-image 属性描述了元素的背景图像，默认情况下，背景图像进行平铺重复显示，以覆盖整个元素实体 background-repeat 属性描述北京图像的平铺属性background-repeat:repeat-x;设置背景图像水平平铺background-repeat:no-repeat;设置背景图像不平铺 background-attachment 背景图像是否固定 background-position 设置背景图像起始位置 4.2 文本 属性 描述 实例 color 设置文本颜色 body{color:red;} direction 设置文本方向 object.style.direction=&quot;rtl&quot;or&quot;ltr&quot; letter-spacing 设置字符间距 letter-spacing:2px line-height 设置行高 line-height:90% text-align 元素中文本对齐方式 text-align:center text-decoration 向文本添加修饰 text-decoration:overline text-indent 缩进元素中文本的首行 text-indent:50px text-shadow 设置文本阴影 text-shadow: 2px 2px #ff0000 text-transform 控制元素中的字母 uppercase lowercase capitalize unicode-bidi 设置或返回文本是否被重写 vertical-align 设置元素的垂直对齐 vertical-align:text-top text-bottom white-space 设置元素中空白的处理方式 word-spacing 设置字间距 word-spacing:30px 4.3 字体 Property 描述 font 在一个声明中设置所有的字体属性 font-family 指定文本的字体系列 font-size 指定文本的字体大小 font-style 指定文本的字体样式 font-variant 以小型大写字体或者正常字体显示文本。 font-weight 指定字体的粗细。 4.4 链接 a:link - 正常，未访问过的链接 a:visited - 用户已访问过的链接 a:hover - 当用户鼠标放在链接上时 a:active - 链接被点击的那一刻 4.5 列表4.6 表格5. 盒子模型所有HTML元素可以看作盒子 CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。 Margin(外边距) - 清除边框外的区域，外边距是透明的 Border(边框) - 围绕在内边距和内容外的边框 Padding(内边距) - 清除内容周围的区域，内边距是透明的 Content(内容) - 盒子的内容，显示文本和图像 6. 定位6.1 尺寸 属性 描述 height 设置元素的高度。 line-height 设置行高。 max-height 设置元素的最大高度。 max-width 设置元素的最大宽度。 min-height 设置元素的最小高度。 min-width 设置元素的最小宽度。 width 设置元素的宽度。 6.2 显示visibility:hidden可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间。也就是说，该元素虽然被隐藏了，但仍然会影响布局。 display:none可以隐藏某个元素，且隐藏的元素不会占用任何空间。也就是说，该元素不但被隐藏了，而且该元素原本占用的空间也会从页面布局中消失 display 属性的值为 “inline”的结果 两个元素显示在同一水平线上 display 属性值为 “block” 的结果 这两个元素之间的换行符 6.3 static默认值，即没有定位，静态定位元素不受定位元素 top buttom left right 影响 6.4 relative相对定位元素的定位是相对其正常位置。 6.5 absolute绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于&lt;html&gt; absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute 定位的元素和其他元素重叠 6.6 fixed元素的位置相对于浏览器窗口时固定位置 Fixed定位使元素的位置与文档流无关，因此不占据空间。 Fixed定位的元素和其他元素重叠。 6.7 position:relative + position:absolute父元素定位为 relative 子元素定位为 absolute 如果我们在div-1上设置相对位置，div-1中的任何元素将相对于div-1定位 6.8 floatCSS 的 Float（浮动），会使元素向左或向右移动，其周围的元素也会重新排列。 Float（浮动），往往是用于图像，但它在布局时一样非常有用。 元素浮动之后，周围的元素会重新排列，为了避免这种情况，使用 clear 属性。clear 属性指定元素两侧不能出现浮动元素 clear:both overflow清除浮动，元素不溢出，父元素宽度以最大元素为基准 6.9 百分比宽度能够更好的适应页面 7. 媒体查询8. displayblockdiv 是一个标准的块级元素。一个块级元素会新开始一行并且尽可能撑满容器。其他常用的块级元素包括 p、 form 和 HTML5 中的新元素： header、 footer、 section等等。 每个块级元素都从新的一行开始，并且其后的元素也另起一行。（一个块级元素独占一行） 元素的高度、宽度、行高以及顶和底边距都可设置。 元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度 inlineinline span 是一个标准的行内元素。一个行内元素可以在段落中&lt;span&gt;像这样 &lt;/span&gt;包裹一些文字而不会打乱段落的布局。 a元素是最常用的行内元素，它可以被用作链接。 none 把 display 设置成 none不会保留元素本该显示的空间，但是 visibility: hidden;还会保留 和其他元素都在一行上； 元素的高度、宽度、行高及顶部和底部边距不可设置； 元素的宽度就是它包含的文字或图片的宽度，不可改变 inline-block同时具有 block 的宽高特性又具有 inline 的同行元素特性","categories":[],"tags":[{"name":"前台","slug":"前台","permalink":"http://yoursite.com/tags/前台/"}]},{"title":"linux 下配置 ss","slug":"20170831","date":"2017-08-31T07:41:44.000Z","updated":"2019-08-04T03:36:40.531Z","comments":true,"path":"2017/08/31/20170831/","link":"","permalink":"http://yoursite.com/2017/08/31/20170831/","excerpt":"","text":"linux 下配置 ss1. gui 方式 安装shadow-qt5 linux ss github地址 在这里 添加PPA源：sudo add-apt-repository ppa:hzwhuang/ss-qt5 更新软件列表：sudo apt-get update 安装shadowsocks：sudo apt-get install shadowsocks-qt5 2. 命令方式 安装python-pip：apt-get install python-pip 安装shadowsocks：pip install shadowsocks 启动客户端sslocal -s server_ip -p server_port -l 1080 -k password -t 600 -m aes-256-cfb -k 密码要加”双引号” 3.chrome 代理设置 安装switchOmage 代理插件 安装好插件后新建情景模式比如命名为SS，其他默认之后创建，之后在代理协议选择SOCKS5，地址为127.0.0.1,端口默认1080（保证此处端口号和上面设置的一致） 。然后保存即应用选项。 接着点击自动切换（auto switch），上面的不用管，在按照规则列表匹配请求后面选择刚才新建的SS，默认情景模式选择直接连接。点击应用选项保存。 再往下规则列表设置选择AutoProxy 然后将这个地址填进去，并将此处的url设置为规则列表网址，点击立即更新情景模式 全局翻墙 安装配置proxychains 全局翻墙通过proxychains实现，即将任何程序和ss的proxy建立链接，原理和浏览器的代理相似。 下载 sudo apt-get install proxychains 配置 sudo nano /etc/proxychains.conf //nano比vim对新手更友好 在最后的ProxyList里加入Shawdowsocks的代理设置： socks5 127.0.0.1 1080 使用，打开ss-qt5的前提下，在需要翻墙的命令前打上proxychains即可。","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]}]}